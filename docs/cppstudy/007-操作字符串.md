---
title: 操作字符串
createTime: 2025/11/18 21:18:18
permalink: /cppstudy/oi0y4kfm/
---

## C 风格字符串

在 [第五章 数组和循环#字符数组](./005-数组和循环.md#字符数组) 中介绍过 C 风格字符串，即以 `'\0'` 字符结尾的字符数组。标准库 `<cstring>` 中提供了许多函数，用于操作 C 风格字符串。下表列出来一些常用的函数

|函数原型| 描述 |
|:------|:-----|
|`char * strncpy(char *dest, const char *src, size_t n)`| 拷贝 `n` 个字符到 `dest` 字符数组中 |
|`size_t strlen(const char *src);`| 获取字符串中的字符数，不包括终止的空字符 `'\0'` |
|`char * strncat(char *dest, const char *src, size_t n);`| 追加`n` 个字符到 `dest` 字符数组的末尾 |
|`int strncmp(const char *s1, const char *s2, size_t n);`| 按编码比较 `s1` 和 `s2` 中的前 `n` 个字符 |
|`char *strchr(const char *str, int c)`| 查找字符 `c` 第一次出现在 `str` 中的位置 |
|`char *strrchr(const char *str, int c)`| 查找字符 `c` 最后一次出现在 `str` 中的位置 |
|`char *strstr(const char *str, const char *substr);`| 查找 `substr` 第一次出现在 `str` 中的位置|
|`char *strtok(char *str, const char *delim)`| 分割字符串 `str`，以 `delim` 中的字符作为分隔符 |

上表列出的所有函数都是在 `<cstring>` 头文件中定义的，使用时需要包含该头文件。

::: warning

`<cstring>` 只是 C 标准库 `<string.h>` 在 C++ 中的对应头文件，二者内容完全相同，但 C++ 版本的头文件将所有内容都放在了 `std` 命名空间中。

这些函数完全是基于空字符 `'\0'` 作为结尾的约定来操作字符串的。如果空字符被遗漏或者覆盖，这些函数就会操作字符串尾部后面的内存，直到某个位置遇到空字符为止。

这种行为可能会导致未定义行为，甚至程序崩溃。因此，在使用这些函数时，一定要确保字符串正确地以空字符结尾，并且目标字符数组有足够的空间来存储结果字符串和终止的空字符。

:::

## string 类型

C++ 标准库 `<string>` 模块中定义了 `string` 类型用于操作字符串，这是 C++ 中操作字符串的推荐方式。该类型要比 C 风格字符串更安全、更方便。

`std::string` 类型由一个类（准确的来说，是类模板）定义，所以它不是基本类型，而称为复合类型。**复合类型** 是组合了若干个数据项的类型，这些数据项最终都是根据基本数据类型定义的。

`string` 对象包含的字符构成了它所表示的字符串，还可以包含其他数据，例如字符的个数。因为 `string` 类型在 `<string>` 模块中定义，所以在使用 `string` 类型之前必须导入这个模块。`string` 类型名称也在 `std` 名字空间中定义，所以需要使用 `std::string` 来访问它，或者使用 `using` 声明将它引入当前作用域。

### 定义 string 对象

`std::string` 类型的对象包含 `char` 类型的字符序列，该字符序列可以为空。用下面的语句可以定义 `string` 类型的变量，它包含一个空字符串

```cpp
std::string empty; // 定义一个空字符串
```

这条语句定义了一个 `string` 对象，可以使用名称 `empty` 来引用它。在本例中，`empty` 是一个不包含字符的字符串，其长度为 $0$

在定义 `string` 对象时，可以使用字符串字面值来初始化它，例如

```cpp
std::string proverb {"Many a mickle makes a muckle."};
```

其中，`proverb` 是一个 `string` 对象，它包含初始化列表中字符串字面量的副本。`string` 对象封装的字符数组总是用空字符终止。这是为了与期望接收 C 风格字符串的众多现有函数保持兼容。

不过，所有的 `std::string` 函数都被特别定义，使得通过不必再担心终止空字符。例如，使用成员函数 `length()` 可以获得 `string` 对象的字符串长度。这个长度不包含字符串的终止字符

```cpp
std::cout << proverb.length() << std::endl; // 输出 29
```

这条语句调用 `proverb` 对象的 `length()` 成语函数，给 `cout` 输出返回的值。对象本身记录字符串的长度。即，要确定封装的字符串长度，`string` 对象不需要遍历整个字符串来寻找终止字符。如果追加一个或多个字符，其长度会自动增加合适的值；如果去除字符，其长度也会相应自动减少

::: warning

`std::string` 对象有两个成员函数 `c_str()` 和 `data()`，它们都返回一个指向 C 风格字符串的指针。只有在调用遗留的 C 样式的函数时，才应该调用这个两个成员函数中的一个。

+ `c_str()` 用于获得一个 C 风格的字符串。即，`const char *` 指针。因为是指向常量的指针，所以不能使用该指针来修改 `string` 对象中的字符，而是只能访问它们

+ `data()` 返回的是 `char *` 类型的指针（C++17 及更高版本）。可以通过这个指针修改字符串中的字符。但是，禁止添加和删除字符，否则会破坏 `string` 对象的内部状态，导致未定义行为。

注意：如果 `proverb` 是 `const` 类型的 `std::string` 对象，那么 `data()` 也会返回 `const char *` 类型的指针。在 C++17 之前，使用 `data()` 总是得到一个 `const char *` 指针，即使对于像 `c_str()` 这样的非 `const string` 也是如此

:::

除了使用字符串字面值初始化外，还可以使用其他方式初始化 `std::string` 对象，例如

```cpp
std::string sleeping(6, 'z'); // 包含 6 个 'z' 字符的字符串
```

`sleeping` 对象包含 $6$ 个字符 `'z'`，也就是说，`sleeping` 中包含字符串 `"zzzzzz"`。这就是使用同一个字符的任意个实例来初始化 `string` 对象的方式。

::: danger

要使用重复字符值来初始化 `std::string` 对象，**就必须使用函数式初始化**，而不能使用列表初始化语法。例如

```cpp
std::string sleeping {6, 'z'};  // 不是我们期望的结果
```

上述语句虽然能通过编译，但是不会是我们期望的结果。在本例中，字面值 `6` 会被解释为一个字符的编码，这意味着 `sleeping` 会被初始化为一个莫名奇妙的单词。它包含两个字符，但不是我们期望的 `"zzzzzz"`

:::

有时候，我们只希望使用字符串字面值中的某个部分来初始化 `std::string` 对象。例如

```cpp
std::string part{ "Least said soonest mended.", 5};  // 包含 "Least" 的字符串
```

在这个初始化器中的第二个值用于指定从第一个值中提取多少个字符来初始化 `part` 对象。

还可以使用 `string` 对象来初始化另一个 `string` 对象。假定 `proverb` 已定义，就可以使用下面的语句定义另一个对象

```cpp
std::string sentence {proverb}; // 使用 proverb 初始化 sentence
```

使用从 $0$ 开始的索引值可以引用 `string` 对象中的字符，这与数组一样。因此，可以使用一对索引值标识已有 `string` 对象的一部分，使用它初始化一个新的 `string` 对象

```cpp
std::string phrase {proverb, 0, 13}; // 包含 13 个字符，来自与 proverb 的开头
```

下图展示了这个过程

![1764601604924-d1aa34794ab320085a5eb2d7e0e530e2.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1764601604924-d1aa34794ab320085a5eb2d7e0e530e2.png)

初始化列表中的第一个元素是初始化字符串中源。第二个元素是 `proverb` 中开始初始化子字符串的字符索引，第三个元素是子字符串中字符的个数。所以，`phrase` 对象包含 `proverb` 对象中的前 $13$ 个字符，即字符串 `"Many a mickle"`。

为了演示创建了哪个子字符串，可以在输出流 `cout` 中插入 `phrase` 对象

```cpp
std::cout << phrase << std::endl; // 输出 Many a mickle
```

然后可以像 C 样式的字符串那样输出 `string` 对象。也可以从 `cin` 中提取 `string` 对象

```cpp
std::string name;
std::cout << "Enter your name: ";
std::cin >> name; // 从标准输入提取字符串
```

这个代码块会读取字符，直到遇见第一个空白字符为止，它会结束输入过程。读取的内容会存储在 `string` 对象 `name` 中。不能用这个过程输入包含空格的文本。当然，读取带空格的完整行文本，可以使用标准库 `<string>` 模块中的 `getline()` 函数

下表总结了前面提到定义和初始化 `string` 对象的 $6$ 种方式

|方式|描述|
|:----|:----|
|`std::string empty`|没有初始化列表(或者空列表`{}`)，初始化为空字符串|
|`std::string proverb {"Many a mickle makes a muckle."}`|使用字符串字面值初始化字符串|
|`std::string part {"Least said soonest mended.", 5}`|使用字符串字面值的一部分初始化字符串|
|`std::string sleeping(6, 'z')`|使用重复字符初始化字符串|
|`std::string phrase {proverb, 0, 13}`|使用已有字符串的一部分初始化字符串|

此外，还可以通过已有的 `std::string` 对象和一个整数初始化 `string` 对象。所创建的 `string` 对象包含从给定索引位置开始的子字符串。例如

```cpp
std::string string {"Consistency is the key to success"};
std::string sub_string {string, 15}; // 包含 "the key to success"
// 从索引为 15 位置开始，直到字符串末尾
```

### string 对象的操作

对 `std::string` 对象可以执行许多操作，最简单的操作是赋值。可以把字符串字面量或一个 `std::string` 对象赋予另一个 `std::string` 对象。例如

```cpp
std::string adjective {"hornswoggling"};
std::string word {"rubbish"};
word = adjective; // 现在 word 包含 "hornswoggling"
adjective = "twotiming"; // 现在 adjective 包含 "twotiming"
```

第三条语句把 `adjective` 的值 `"hornswoggling"` 赋给 `word`，替换掉 `"rubbish"`。最后一条语句给 `adjective` 赋予字符串字面量 `"twotiming"`，替换掉了初始值 `"hornswoggling"`。这样，执行这些语句后，`word` 就包含 `"hornswoggling"`, `adjective` 包含 `"twotiming"`。

#### 连接字符串

使用加号运算符 `+` 可以连接字符串。下面用刚才定义的对象来演示连接

```cpp
std::string description {adjective + " " + word + " " + whippersnapper};
```

执行这条语句后，`description` 对象就包含字符串 `"twotiming hornswoggling whippersnapper"`。显然，使用 `+` 运算符可以把字符串字面量与 `string` 对象连接在一起。这是因为对 `+` 运算符重新进行了定义，使 `string` 对象有了一个特殊的含义。当一个操作数是 `string` 对象时，另一个操作数是 C 风格字符串或者 `string` 对象时，执行 `+` 操作的含义就是：创建一个新的 `string` 对象，它把两个字符串连接成为一个字符串

::: warning

注意：**不能用 `+` 运算符来连接两个 C 风格字符串**。C 风格字符串本质上就是 `[const] char *` 类型的指针，C++ 中两个指针是不允许相加的。

`+` 运算符的操作数必须有一个是 `string` 类型的对象。例如，如下语句就不会进行编译

```cpp
std::string description {" whippersnapper" + " " + word}; // error
```

问题在于编译器试图把初始值计算为

```cpp
std::string description {(" whippersnapper" + " ") + word}; // error
```

换句话说，它计算第一个表达式是 `(" whippersnapper" + " ")`，而 `+` 运算符不能操作两个 C 风格字符串。

:::

针对上述问题，在 C++ 中至少有 $5$ 中解决方法

```cpp
// 1. 将前两个字符串字面值合并
std::string description {" whippersnapper " + word}
// 2. 省略字符串字面值之间的 +：编译器会自动合并两个相邻的字面值
std::string description {" whippersnapper" " " + word}
// 3. 使用圆括号，改变计算顺序
std::string description {" whippersnapper" + (" " + word)}
// 4. 将使用字符串字面值初始化一个 string 对象
std::string description {std::string{" whippersnapper"} + " " + word}
// 5. 使用自定义字面值: 后缀 "..."s 表示 string 类型的字面值
using namespace std::string_literals;  // 使用 s 后缀表示 `string` 类型必须添加该语句
std::string description {" whippersnapper"s + " " + word}
```

::: warning

如果想要使用 `std::string` 类型的字面值，就需要将 `using namespace std::string_literals` 指令添加进来

:::

来看下面一个示例程序，该示例程序从键盘上读取姓名

```cpp
#include <iostream>
#include <string>

int main()
{
    std::string first;  // ""
    std::string second; // ""

    std::cout << "Enter your first name: ";
    std::cin >> first;

    std::cout << "Enter your second name: ";
    std::cin >> second;

    std::string sentence {"Your full name is "};
    sentence += first + " " + second + ".";

    std::cout << sentence << std::endl;
    std::cout << "The string countains " << sentence.length() << " characters." << std::endl;
}
```

::: tip

可以使用 `std::string` 对象的 `append()` 成员函数来替代 `+=` 运算符。使用该函时，可以像下面一样进行链式调用

```cpp
sentence.append(first).append(" ").append(second).append(".");
```

`append()` 成员函数比 `+=` 运算符更灵活，允许连接子字符串或重复字符

```cpp
std::string compliment{"~~~ What a beautiful name... ~~~"};
compliment.append(compliment, 3, 22);  // 添加 "What a beautiful name"
compliment.append(3, '!'); // 添加 "!!!"
```

:::

#### 连接字符

`std::string` 类型对象除了连接另一个 `string` 类型对象和字符串字面值外，还可以连接字符。例如

```cpp
sentenct += first + ' ' + second + '.';
```

当然，两个字符也是不能使用 `+` 运算符进行连接，因为 C++ 会把字符当作整数处理。

```cpp
sentence += second;
sentence += ',' + ' ';  // [!code highlight] 
sentence += first;
```

注意，上述代码片段可以通过编译，但是由于 C++ 把字符当作整数进行处理，字符 `','` 的编码值是 $44$，字符 `' '` 的编码值是 $32$，因此它们的和是 $76$，正好是字符 `'L'` 的编码。因此，上述代码片段完全在语法上完全正确，但是执行的最终结果却完全不符合预期

当然，如果像下面这样写就完全不会有问题

```cpp
sentence += second + ',' + ' ' + first;
```

原因在于，运算符 `+` 左相关的。因此，编译器会从左到右计算语句，如同下面的增加圆括号的语句一样

```cpp
sentence += ((second + ',') + ' ') + first;
```

::: warning

目前，我们都是将字符串字面值或者字符字面值与 `std::string` 类型进行连接。

在任何使用字符串字面值的地方都可以使用 C 风格字符串的其他形式替换，也就是说，可以使用 `[const] char *` 或者 `char[]` 类型变量与 `std::string` 类型的对象进行连接

:::

#### 连接数字

**C++ 不允许将 `std::string` 与字符串或者字符之外的其他类型进行连接**。例如，`double` 类型一般会导致编译错误

```cpp
const std::string result_string {"The result equals: "};
double result = std::numbers::pi;

std::cout << (result_string + result) << std::endl; // 编译错误
```

::: danger

最糟糕的就是 `std::string` 对象与整数进行连接，由于 C++ 将字符类型当作整数进行处理。因此，`std::string` 对象与整数连接是完全符合语法规则的。只是，不能得到我们想要的结果。例如

```cpp
std::string song_title {"Summer of'"};
song_title += 69;
std::cout << song_title << std::endl; // "Summer of 'E"
```

C++ 会将 $69$ 转换为对应编码的字符。而不是将其转化为字符串 `"69"`。我们必须使用标准库中的 `<string>` 模块提供的 `std::to_string()` 函数将基本类型转换为 `std::string` 对象

```cpp
std::string song_title {"Summer of'"};
song_title += std::to_string(69);
std::cout << song_title << std::endl; // "Summer of '69"
```

该函数也是存在缺陷的。不能使用该函数控制格式。因此，`std::to_string()` 总是会将浮点数以 $6$ 位小数格式输出

:::

当需控制格式时，请使用 `std::format()` 函数或者标准库中的 `<iomanip>` 模块

### 访问 string 中的字符

可以使用 `[index]` 形式，通过索引值来访问对应位置上的字符，甚至是修改这个字符，就行处理字符数组一样。`std::string` 对象中的第一个字符的索引是 $0$。例如，`sentence` 中的第三个字符可以通过 `sentence[2]` 表达式访问。下面的循环把 `sentenc` 中的所有字符改为大写

```cpp
for (size_t i{}; i < sentenc.length(); ++i>)
{
    sentence[i] = static_cast<char>(std::toupper(sentence[i]));
}
```

这里使用 `static_cast<>` 是为了避免编译器警告，因为 C 库函数 `toupper()` 的返回类型是 `int`，而不是期望的 `char` 类型

`std::string` 对象是一个范围，所以可以使用基于范围 `for` 循环完成上述操作

```cpp
for (auto &c : sentence)  // 注意，这里是左值引用
{
    c = static_cast<char>(std::toupper(c));
}
```

下面的示例程序演示了使用 `string` 类型版本的确定字符串中元音和辅音字母的个数

```cpp title="vowels2.cpp"
#include <iostream>
#include <string>

#include <cctype>

int main()
{
    std::string text;
    std::cout << "Enter a line of text: " << std::endl;
    std::getline(std::cin, text);  // 从 std::cin 中读取一行到 text 中
    
    std::cout << "You entered:\n" << text << std::endl;
    size_t vowels{};  // 元音字母个数
    size_t consonants{};  // 辅音字母个数

    for (const auto &ch: text)  // 我们不希望修改 text 中的字符 // [!code highlight]
    {
        // text[i] 是一个字母
        if (std::isalpha(ch))
        {
            switch (std::tolower(ch))
            {
            case 'a':
            case 'e':
            case 'i':
            case 'o':
            case 'u':
                ++vowels;  // 元音字母个数 +1
                break;
            default:
                ++consonants;  // 辅音字母个数 +1
                break;
            }
        }
    }
    std::cout << "Your input contained " << vowels << " vowels and "
        << consonants << " consonants." << std::endl;
    return 0;
}
```

这个示例程序是在 [第五章 数组和循环#字符数组](./005-数组和循环.md#字符数组) 中的 `vowels.cpp` 示例程序的改进版本，主要的优点就是不需要考虑输入字符串的长度

::: tip

这里我们使用了在标准库 `<string>` 模块中定义的 `std::getline()` 函数，它从第一个参数(输入流)中读取字符，直到遇见换行符位置，并把输入存储在第二个实参指定的 `string` 对象 `text` 中。这次，我们不需要考虑输入中有多少个字符。`string` 对象自动容纳输入的内容，并记录其长度

如果需要修改结束符，还可以指定第三个实参，例如，使用 `'#'` 作为结束符

```cpp
std::getline(std::cin, text, '#');
```

:::

### 访问子串

使用 `substr()` 成员函数可以获取 `string` 对象的一个子字符串。这个函数需要两个实参。第一个实参指定子字符串开始的索引位置，第二个实参指定子字符串中的字符个数。该函数返回一个包含子字符串的 `string` 对象

```cpp
std::string phrase {"The higher the fewer."};
std::string word {phrase.substr(4, 6)}; // "higher"
```

这两行代码从 `phrase` 的索引位置为 $4$ 的地方开始，提取 $6$ 个字符的子字符串，于是在执行第二条语句之后，`word` 就包含了 `"higher"`。

如果指定的子字符串长度超过了 `string` 对象的结尾，或者省略第二个实参，`substr()` 函数就返回从指定位置开始到该字符串最后的所有字符。例如

```cpp
std:string word {phrase.substr(4, 100)};  // "higher the fewer."
// 省略子字符串的长度也会得到相同的结果
std::string word {phrase.substr(4)}; // higher the fewer."
```

::: warning

如果为子字符串指定的起始索引位置超出了要处理 `string` 对象的有效边界，则抛出 `std::out_of_range` 类型的异常，程序将异常终止，除非捕获并处理异常。将在 [第十六章 运行时错误和异常](./016-运行时错误和异常.md) 中介绍

:::

### 比较字符串

在 `vowels2.cpp` 示例程序中介绍了如何使用索引访问 `string` 对象中的各个字符，以进行比较。由于在使用索引值访问单个字符时，结果为 `char` 类型，因此可以使用比较运算符比较各个字符。也可以使用比较运算符比较整个 `string` 对象

在 [第四章 决策#比较数据值](./004-决策.md#比较数据值) 中介绍的所有运算符都可以用于比较两个 `string` 对象，或者比较 `string` 对象与 C 风格字符串

::: tip

`string` 对象之间进行比较时，操作数将逐个比较其中的字符，直到找到不同的字符，或者其中一个操作数的字符耗尽。在找到不同字符时，比较字符的在字符集中代码数值决定整个字符串的大小。如果没有找到不同的字符，但字符串有不同的长度，则较短的字符串小于较长的字符串。如果两个字符串包含相同数量的字符，且对应字符都相同，则两个字符串相等。


注意：由于比较的字符编码，因此这种比较区分大小写。此外，这种字符串比较算法的技术术语是 **字典序比较**，意识就是指字符串按照字典中的顺序比较

:::

下面的示例程序将读取许多姓名，并按升序排列它们

```cpp title="name.cpp"
#include <iostream>
#include <format>
#include <string>
#include <vector>

int main()
{
    std::vector <std::string> names;  // name 数组

    std::string name;  // 每次输入的name

    for (;;)
    {
        std::cout << "Enter a name followed by Enter (leave blank to stop): ";
        std::getline(std::cin, name);   // 输入一个名字
        if (name.empty())
            break;
        names.push_back(name);  // 添加到 vector 中
    }

    // 使用冒泡排序将名字进行排序
    for (size_t i{  }; i < names.size(); ++i)
    {
        bool sorted{true};
        for (size_t j{ 0 }; j < names.size() - i - 1; ++j)
        {
            if (names[j] > names[j + 1])
            {
                names[j].swap(names[j + 1]); // [!code highlight]
                sorted = false;
            }
        }
        if (sorted)
        {
            break;
        }
    }
    // 找出最长的名字
    size_t max_length{};
    for (const auto& name : names)
    {
        if (max_length < name.length())
        {
            max_length = name.length();
        }
    }
    // 输出
    const size_t field_width = max_length + 2;

    size_t count{};

    std::cout << "In ascending sequence the names you enterd are: \n";
    for (const auto& name : names)
    {
        std::cout << std::format("{:>{}}", name, field_width);// 右对齐 // [!code highlight]
        if (!(++count % 5)) std::cout << std::endl;
    }
    std::cout << std::endl;
}
```

排序过程使用了冒泡排序。因为需要比较 `std::vector<>` 中连续的元素，在需要时交换元素，索引需要使用 `for` 循环迭代 `vector<>`，而不能使用范围 `for` 循环。

在 `for` 循环中的 `names[j].swap(names[j + 1]);` 语句交换了 `string` 对象的内容。等价于下面一些了赋值语句

```cpp
std::string temp {names[j]};
names[j] = names[j+1];
names[j+1] = temp;
```

请注意：大部分标准库类型都提供了 `swap()` 成员函数。除了 `std::string`，还包括全部容器类型，全部的智能指针。`std` 名字空间中还定义了一个模板函数 `std::swap()`，可以使用同样的效果

```cpp
#include <utility>

std::swap(names[j], names[j+1]);
```

这个函数可以用于基本类型。当然，要使用这个函数需要先导入 `<utility>` 标准库

最后在输出名字时使用了一个全新的格式模板 `"{:>{}}"`，即 **动态宽度**。也就是说，输出结果的宽度没有硬编码到格式字符串中，而是由第二个实参 `field_width` 决定

#### 三向比较运算符 `<=>`

在单个表达式中，三向比较运算符用于确定某值是否小于、大于、等于另一个值。对于基本类型数据，三向比较运算符的作用实际上很小。然而，像字符串这样的复合对象，它强大功能得以显现。下面说明这一点

```cpp
std::string s1 {"Little Lily Lovelace likes licking lollipops."};
std::string s2 {"Little Lily Lovelace likes leaping lizards."};

if (s1 < s2)
{
    ...
}
else if (s1 > s2)
{
    ...
}
else
{
    ....
}
```

上述代码片段中，当确定第一个 `if` 条件 `s1 < s2` 为 `false`时，从理论上就可以推断出 `s1 > s2` 为 `true`。不过，为了计算表达式 `s1 > s2` 的值，就还需对 `s1` 和 `s2` 进行重复比较。但是，使用三向比较运算符就可以解决这种低效

在 C++20 中，有两种方法可以实现 `string` 对象的三向比较。一种是使用 `<=>` 比较运算符，另一种是使用 `compare()` 成员函数。首先，我们来看使用 `<=>` 比较运算符的情形

```cpp
const auto order = s1 <=> s2;  // 返回 std::strong_ordering 类型
if (std::is_lt(order))  // s1 < s2
{
    ...
}
else if (std::is_gt(order)) // s1 > s2
{
    ...
}
else
{
    ...
}
```

如果使用 `compare()` 成员函数，同样可以比较 `s1` 和 `s2`。例如

```cpp
const auto ordering = s1.compare(s2);

if (ordering < 0)  // s1 < s2
{
    ...
}
else if (ordering > 0) // s1 > s2
{
    ...
}
else
{
    ...
}
```

与 `<=>` 运算符不同的是，成员函数 `compare()` 会返回一个 `int` 类型的整数。整数与 $0$ 的大小关联了字符串的大小

|返回值|描述|
|:---|:---|
| 小于 $0$ | `s1 < s2` |
| 大于 $0$ | `s1 > s2` |
| 等于 $0$ | `s1 == s2`|

::: tip

`compare()` 成员函数还支持比较子字符串。例如

```cpp
std::string word1 {"A jackhammer"};
std::string word2 {"jack"};

// word1[2, 2+word2.length()] 与 word2 进行比较
const auto order = word1.compare(2, word2.length(), word2);
```

表达式 `word1.compare(2, word2.length(), word2)` 表示将子串 `word1.substr(2, word2.length())` 与 `word2` 进行比较。即等价于 `word1.substr(2, word2.length()) <=> word2`

:::

### 检查字符串的开头和结尾

有时候，需要检查字符串是否以给定的字符串开始或结束。当然，可以使用使用 `compare()` 或 `substr()` 成员函数实现

```cpp
std::string text {"Start with the end in mind."}

// 使用 compare()
if (text.compare(0, 5, "Start") == 0)
{
    std::cout << "The text starts with 'Start'.\n";
}
// 使用 substr()
if (text.substr(text.length() - 3, 3) != "end")
{
    std::cout << "The text does not end with 'end'.\n";
}
```

这种方法可读性不好，并且很容易使用错误的子字符串索引。因此， C++20 标准引入了两个有用的成员函数来解决这个问题：`starts_with()` 和 `ends_with()`

```cpp
std::string text {"Start with the end in mind."}
if (text.starts_with("Start"))
{
    std::cout << "The text starts with 'Start'.\n";
}
if (!text.ends_with("end"))
{
    std::cout << "The text does not end with 'end'.\n";
}
```

这样提高代码可读性。除了 C 风格字符串或者 `string` 对象外，这两个函数还接受单个字符

```cpp
if (text.ends_with('.'))
{
    std::cout << "The text ends with a period.\n";
}
```

而且，在空字符串上使用 `starts_with()` 和 `ends_with()` 成员函数也是安全的（自然，对于空字符串，总是返回 `false`）。对于 `[]` `front()` `back()` 或者 `substr()` 在空字符串上可能会引发 `std::out_of_range` 类型的异常


### 搜索字符串

可以使用 `compare()` 成员函数来搜索子字符串。例如

```cpp
std::string text {"Peter piper picked a peck of pickled peppers."};

sdt::string word {"pick"};
for (size_t i {}; i < text.length() - word.length() + 1; ++i)
{
    if (text.compare(i, word.length(), word) == 0)
    {
        std::cout << "text contains " << word << " starting at index " << i << std::endl;
    }
}
```

这里我们循环遍历整个 `text`，循环变量的上限就是 `text.length() - word.length()`。最终，我们在 `text` 的索引位置为 $12$ 和 $29$ 俩个位置找到 `word`

除了 `compare()`，搜索 `string` 对象还有许多不同的方法，它们所涉及的函数都会返回查找字符串的索引位置。首先，我们从最简单的搜索开始。`string` 对象有一个成员函数 `find()`，它可以确定字符串中子字符串或者给定字符的索引位置。例如

```cpp title="find.cpp"
#include <iostream>
#include <string>
#include <limits>

int main()
{
    std::string sentence{ "Manners maketh man" };
    std::string word{ "man" };
    std::cout << sentence.find(word) << std::endl;  // 15
    std::cout << sentence.find("Ma") << std::endl;  // 0
    std::cout << sentence.find('k') << std::endl;   // 10
    std::cout << sentence.find('x') << std::endl;   // std::string::npos 没有找到返回一个无效值(std::string::npos), 
    std::cout << std::numeric_limits<size_t>::max() << std::endl;  // size_t 类型的最大值
}
```

上述示例程序中的每一个 `find()` 函数的调用，都会从 `sentence` 的开始位置进行查找，并返回搜索到的第一个子字符串中第一个字符的索引位置。如果没有找到，则返回 `std::string::npos`，这是定义在 `<string>` 模块中的常量。上述程序运行的结果如下

```shell
15
0
10
1844674407370955161
```

可以看到，`std::string::npos` 的具体值是一个极大值，具体而言就是 `size_t` 类型的最大值，该类型通常是 `unsigned long long` 类型。因此，该值通常是 $2^{64}-1$。因此，如果需要检查查找是否成功，应该使用下面的示例

```cpp
if (sentence.find('x') == std::string::npop)
{
    // 没找到的处理逻辑
}
```

::: danger

`std::string::npos` 不会被编译器解释为 `false`，因为这不是非零值。然而，$0$ 是一个有效的索引。因此，一定不要写出如下代码

```cpp
if (!sentence.find('x'))
{
    // 没找到的处理逻辑
}
```

当在索引为 $0$ 的位置发现字符 `x` 时，这段代码就会执行没找到字符的处理逻辑

:::

