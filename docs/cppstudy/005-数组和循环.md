---
title: 数组和循环
createTime: 2025/11/16 22:17:52
permalink: /cppstudy/zot30i85/
tags:
  - C/C++
---

**数组** 允许用单个名称(数组名)处理类型相同的几个数据项。这是一个非常常见的需求，例如，处理一组温度值或者一组人的年龄。**循环** 是编程中的另一个基本要素。它允许对一个或多个语句重复执行应用程序需要的次数

## 数组

前面创建的所有变量都可以存储指定类型的一个数据项，例如整数、浮点值、字符、布尔值等。**数组可以存储相同类型的多个数据项**。可以创建整数数组或者字符数组，**实际上，可以创建任何数据类型的数组，只要有可用的内存，数组就可以存储任何类型的数据**

数组表示一系列内存空间的变量，每个内存空间都可以存储相同类型的一个数据项。例如，假定编写了一个程序，用来计算一年温度的平均值。现在要扩展这个程序，计算比该平均值高的温度有多少个，比该平均值低的温度有多少个。此时，需要保存初始的示例数据，但在一个变量中存储每个数据项，程序就会很烦恼，而且不切实可行。使用数组就可以很轻松地完成这个任务。例如

```cpp
double temperatures[366];  // 定义一个长度为 366 的 double  类型的数组 temperatures
```

这个语句定义了一个 `double` 类型的数组，其名称是 `temperatures`，有 $366$ 个值。把数据值称为 **元素**，把在方括号中指定的元素个数称为 **数组的大小**。数组元素没有在这个语句中初始化，所以它们包含垃圾值。

**数组的大小必须用常量整数表达式来指定**。编译器在编译时能够计算的任何整数表达式都可以用于指定数组大小，不过最常用的整数字面值，或者使用字面值进行初始化的 `constexpr` 整型变量

使用一个整数可以引用数组元素，把该整数称为 **数组的索引**。**数组元素的索引是指该元素与数组第一个元素的偏移值**。第一个元素的偏移值是 $0$，因此其索引是 $0$，索引值为 $3$ 表示数组中的第 $4$ 个元素(与第一个元素偏移 $3$ 个元素)。要引用元素，可以在数组名后面的方括号中放置其索引。要把 `temperatures` 数组的第 $4$ 个元素设置为 $99.0$，可以使用如下语句

```cpp
temperatures[3] = 99.0;  // 设置第四个元素为 99.0
```

为了更好的说明数组，来看下面一个数组的定义

```cpp
unsigned int height[6];  // 定义一个长度为 6 的数组 height
```

在执行这个定义语句时，编译器为这 $6$ 个 `unsigned int` 类型的值分配 $6$ 个连续的存储位置。`height` 数组中的每个元素都包含不同的值。因为 `height` 数组的定义没有为数组指定初始值，所以其元素包含的垃圾值(类似于创建一个 `unsigned int` 类型的变量，但不为其指定的初始值)。下面的语句定义了带初始值的数组

```cpp
unsigned int height[6] {26, 37, 47, 55, 62, 75}; // 定义并初始化长度为 6 的数组
```

初始化列表包含 $6$ 个用逗号隔开的值。这些值可能是某个家庭中所有成员的身高，其单位是英寸。每个数组元素都按顺序被赋予列表中的一个初始值，所以元素具有如下图所示的值

![1763307080799-38fd35eb3037375beb8f687ad1515f9e.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1763307080799-38fd35eb3037375beb8f687ad1515f9e.png)

上图中每个框都表示保存数组元素的一个内存位置。该数组中有 $6$ 个元素，其索引是 $0$(表示第一个元素)到 $5$(表示最后一个元素)。每个元素都可以通过上面的表达式来引用

::: warning

数组的类型决定了存储每个数组元素所需要的内存量。数组的所有元素都存储在一个连续的内存块中。因此，如果 `unsigned int` 类型的值在计算机中需要 $4$ 字节，则 `height` 数组就需要占用 $24$ 字节

:::

**初始化列表中值的个数不能超过数组的元素个数**，否则该语句不会编译。初始化列表中值的个数可以少于数组的元素个数，此时没有提供初始值的元素就初始化为 $0$(对于 `bool` 元素数组则为 `false`)

```cpp
unsigned int height[6] {26, 37, 47};  // 元素为: 26 37 47 0 0 0
```

前 $3$ 个元素具有初始化列表中的值。后 $3$ 个元素的值是 $0$。要把所有元素初始化为 $0$，可以仅使用空的初始化列表

```cpp
unsigned int height[6] {};  // 元素为: 0 0 0 0 0 0
```

有时候，我们需要定义其元素不能修改的数组，只需要在类型前面加上关键字 `const`。下面定义了一个 `unsigned int` 常量的数组

```cpp
const unsigned int height[6] {26, 37, 47, 55, 62, 75};  // 常量的数组
```

编译器将阻止修改这 $6$ 个数组元素中的任何一个（无论赋值、递增还是其他修改）。参与算术表达式的数组元素与其他变量一样，可以用下面的语句计算 `height` 数组中前 $3$ 个元素的总和

```cpp
unsigned int sum {};

sum = height[0] + height[1] + height[2];  // 前三个元素的和
```

在表达式中，数组的每个元素可以像普通整数变量那样操作。如前所述，数组元素可以放在赋值运算符的左边，以设置新值，所以可以在赋值语句中把一个元素的值复制给另一个元素，例如

```cpp
height[3] = height[2];  // 拷贝第三个元素的值到第四个元素
```

但是，**不能利用赋值语句把整个数组的所有元素值赋值到另一个数组的元素，只能操作数组中的各个元素**

```cpp
int array1[3] {1, 2, 3};
int array2[3];

array2 = array1;  // error: 不允许对数组名进行赋值
```

因此，要将一个数组的值复制到另一个数组中，就必须一次复制一个值。此时需要使用 **循环**

## 理解循环

**循环** 是一种机制，**允许重复执行一个或一组语句，直到满足指定的条件为止**。循环有两个基本元素：组成循环体的要重复执行的语句或语句块，以及决定何时停止重复循环的循环条件。**将循环体执行一次称为一次迭代**

循环条件有许多不同的形式，通过了控制循环的不同方式。例如，循环条件可以

+ 执行循环，次数为指定的次数
+ 循环一直执行到给定的值超过另一个值为止
+ 循环一直执行到从键盘输入某个字符为止
+ 为一个元素集合中的每个元素执行循环

可以设置循环条件，以适应使用循环的环境。循环有如下变体

+ `for` 循环：**使循环体执行给定的次数**，但有极大的灵活性
+ 基于范围的 `for` 循环：**为一个元素集合中的每个元素执行一次迭代**
+ `while` 循环：只要指定的条件为 `true`，`while` 循环就继续执行。**条件在迭代开始时检查，所以如果条件开始时就是 `false`，就不执行迭代循环**
+ `do-while` 循环：只要给定的条件为 `true`，`do-while` 循环就继续执行。`do-while` 循环与 `while` 循环不同，因为它在迭代结束时检查条件，所以 **`do-while` 循环中的语句至少执行一次**

下面先介绍 `for` 循环的工作原理

## for 循环

`for` 循环主要用于对语句或语句块执行预知的次数，但也可以用于其他方式。可以使用以分号分隔 $3$ 个表达式来控制 `for` 循环，这 $3$ 哥表达式放在关键字 `for` 后的圆括号中

```cpp
for (initialization; condition; iterate)
{
    // 循环体
}
// 下一条语句
```

如下图演示了 `for` 循环的执行逻辑：`initialization` 只在循环的开始处计算一次；接着检查 `condition`，如果它是 `true`，就执行循环语句或语句块；如果循环条件是 `false`，就跳过循环语句，执行循环后面的下一条语句。每次执行了循环语句或语句块后，就计算 `iterate` 表达式。之后，再次检查循环条件，看看是否继续循环

![1763309374425-28064e13251a5305282c7dfa8107f458.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1763309374425-28064e13251a5305282c7dfa8107f458.png)

`for` 循环的一般用法中，第一个表达式用于初始化一个计数器，第二个表达式用于检查这个计数器是否达到给定的极限，第三个表达式用于递增或递减这个计数器。例如

```cpp
double reainfall[12] {1.1, 2.8, 3.4, 3.7, 2.1, 2.3, 1.8, 0.0, 0.3, 0.9, 0.7, 0.5};

double copy [12] {};

for (size_t i {}; i < 12; ++i)  // 初始化 i = 0
{
    copy[i] = reainfall[i];  // 拷贝
}
```

第一个表达式把 `i` 定义为 `size_t` 类型，初始化为 $0$。使用 `size_t` 类型的原因在于 `sizeof` 运算符返回的就是 `size_t` 类型的值。通常，`size_t` 类型是某个无符号整数类型的别名，一般用于计算对象的大小和计数。变量 `i` 用于索引数组，所以使用 `size_t` 类型是有意义的。

第二个表达式是循环条件，只要变量 `i` 小于 $12$，循环条件就是 `true`，循环在变量 `i` 小于 $12$ 是继续执行。变量 `i` 等于 $12$ 时，该表达式就是 `false`，所以循环结束。

第三个表达式在每次循环迭代的末尾递增变量 `i`，所以变量 `i` 的值从 $0$ 变到 $1$ 时，就执行把 `rainfall` 中的第 `i` 个元素复制到 `copy` 中的循环语句块

::: tip

`size_t` 并不是内置的基本类型名称，而是标准库定义的一个类型别名。更具体而言，它是某个无符号整数类型的别名，并且足够大，能够容纳编译器支持的任何类型

别名在 `<cstddef>` 标准库以及其他一些模块中定义。但在实际应用中，大多数时候不需要显示包含这个模块，就能使用 `size_t` 别名

:::

::: danger

**编译器不会检查数组索引值是否有效**。程序员需要自己确保引用的元素不会超出数组边界如果使用超出数组有效范围的索引值来存储数据，那么可能会无意中重写内存中的数据，胡总导致 **段错误** 或 **非法访问**。这两个术语的含义是相同的，**指操作系统在检测到未授权的内存访问时引发错误**。无论是哪种情况，程序几乎一定会异常结束

:::

同往常一样，编译器也会忽略 `for` 语句中的所有空白。另外，如果循环体只包含一条语句，花括号就是可选的。因此，可以把前面的 `for` 循环重写如下形式。请注意：**无论如何都将循环体放入花括号中**

```cpp
for (size_t i {}; i < 12; ++i)  // 初始化 i = 0
    copy[i] = reainfall[i];  // 拷贝
```

---

在 `for` 循环的初始化表达式中定义变量是合法的，也非常常见。此外，还有一些重要的意义。循环定义了一个作用域。循环语句或语句块，包括控制循环的任意表达式，都在循环的作用域内。在循环的作用域内声明的任何自动变量，在循环的外部都不存在。因为变量 `i` 在第一个表达式中定义，所以它是循环的局部变量，循环结束时，变量 `i` 就不存在了。

如果希望在循环结束后仍能访问循环控制变量，可以在循环之前定义它，如下所示

```cpp
size_t i {};

for (i = 0; i < 12; ++i)
{
    copy[i] = rainfall[i];
}
// 变量 i 也可以访问
```

接着就可以在循环后访问变量 `i`，此时的值是 $12$。由于变量 `i` 在定义时被初始化为 $0$，所以第一个循环控制表达式是多余的。可以忽略任意循环控制表达式，所以循环可以重写如下

```cpp
size_t i {};
for ( ; i < 12; ++i)
{
    copy[i] = rainfall[i];
}
```

## 避免幻数

上述代码段存在的一个小问题是数组的大小 $12$ 涉及 **幻数**。假设有人新造出 $13$ 个月份 `Undecimber`，需要添加该月份的降雨量值。此时，很可能在增加了 `rainfall` 数组的大小后忘记更新 `for` 循环中使用的 $12$。`bug` 就是这样出现的

更安全的方法是给数组的大小定义一个 `constexpr` 变量，用它替代显式值

```cpp
constexpr size_t size {12};
double rainfall[size] {1.1, 2.8, 3.4, 3.7, 2.1, 2.3, 1.8, 0.0, 0.3, 0.9, 0.7, 0.5};
double copy [size] {};

for (size_t i {}; i < size; ++i)
{
    copy[i] = rainfall[i];
}
```

这样就不容易出错了，显然，`size` 是指两个数组中元素的个数

::: tip

注意：如果同一个常量值分散在代码的不同地方，很容易忘记在某些地方进行更新，从而导致出错。因此，只应该定义幻数或任何常量一次。如果之后需要修改常量，只需要在一个地方进行修改

:::

下面在一个完整的例子中使用 `for` 循环

```cpp {23-24}
#include <iostream>

int main()
{
    constexpr unsigned size {6};
    unsigned height[size] {26, 37, 47, 55, 62, 75};

    // 计算 height 的总和
    unsigned total {};
    for (size_t i {}; i < size; ++i)
    {
        total += height[i];
    }

    // 计算平均值
    const unsigned average {total / size};
    std::cout << "The average height is " << average << std::endl;

    // 计算身高低于平均身高的人数
    unsigned count {};
    for (size_t i {}; i < size; ++i)
    {
        if (height[i] < average)
            ++count;
    }
    std::cout << count << " people are below average height." << std::endl;
}
```

输出如下

```shell
The average height is 50
3 people are below average height.
```

可以使用下面的语句替换上面的 `if` 语句

```cpp
count += height[i] < average;
// height[i] < average ==> true ==> 1
// height[i] < average ==> false ==> 0
```

这个表达式是有效的，因为比较运算符返回的 `bool` 类型会被隐式转换为 `int` 类型。值 `true` 被转换为 $1$，值 `false` 被转换为 $0$，所以 `count` 仅在比较结果为 `true` 时递增

## 用初始列表定义数组大小

在数组定义中提供初始列表，就可以忽略数组的大小，编译器会自动计算初始列表中元素的个数。例如

```cpp
int values[] {2, 3, 4};
```

这条语句定义了一个数组，它包含了 $3$ 个 `int` 类型的元素，其初始值分别为 $2$、$3$ 和 $4$。该语句等价于

```cpp
int values[3] {2, 3, 4};
```

让编译器自动计算数组大小的优点是，数组的大小不会出错。

### 确定数组的大小

前面介绍了如何定义一个常量来初始化数组的大小，从而避免给数组的元素个数使用幻数。让编译器根据初始化列表确定元素个数时，也不希望给数组的大小指定幻数。在必要时，需要一种确定数组大小的验证方法

最简单也是推荐使用的方法是使用标准库的 `<array>` 模块中提供的 `std::size()` 函数。假设定义下面的数组

```cpp
int values [] {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};
```

然后，就可以使用 `std::size(values)` 表达式来获得数组 `vlaues` 的大小。函数 `std::size()` 使用非常方便，因此在 C++17 标准中添加到标准库的

::: tip

`std::size()` 函数不只用于数组，还可以用来获得标准库定义的任何元素集合的大小，包括后面介绍的 `std::vector<T>` 和 `std::array<T>` 容器

:::

在 C++17 标准之前，通常是基于 `sizeof` 运算符计算数组的大小。在 [第二章 基本数据类型#整型的尺寸](002-基本数据类型.md#整型的尺寸) 中介绍过，`sizeof` 运算符返回变量占用的字节数，它适用于整个数组和单个数组元素。因此，`sizeof` 运算符提供了确定数组中元素个数的方法：**只需要用数组的大小除以单个元素的大小即可**

```cpp
#include <iostream>
#include <array>

int main()
{
    int values [] {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};

    std::cout << "There are " << std::size(values) << " elements in the array.\n";  // [!code highlight]

    int sum {};
    const size_t array_size = sizeof(values) / sizeof(values[0]); // [!code highlight]
    for (size_t i {}; i < array_size; ++i)
    {
        sum += values[i];
    }
    std::cout << "The sum of the array elements is " << sum << std::endl;
}
```

这个示例的输出如下

```shell
There are 10 elements in the array.
The sum of the array elements is 129
```

编译器会通过数组定义中初始值的数量来确定 `values` 数组的元素个数。在第一个输出语句中使用了 `std::size()` 函数计算数组 `values` 的大小。对于 `array_size` 变量，使用了 `sizeof` 运算符计算数组元素个数，这样做不清楚也不简单。

为了简化使用 `sizeof` 运算符计算数组元素个数，可以定义一个 **函数式宏**。例如

```cpp
#include <iostream>
#include <array>

#define SIZE(array) (sizeof((array)) / sizeof((array)[0]))  // [!code focus]

int main()
{
    int values [] {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};

    std::cout << "There are " << std::size(values) << " elements in the array.\n";

    int sum {};
    constexpr size_t array_size = SIZE(values);  // [!code focus]
    for (size_t i {}; i < array_size; ++i)
    {
        sum += values[i];
    }
    std::cout << "The sum of the array elements is " << sum << std::endl;
}
```

显然，使用 `std::size()` 函数更容易理解。因此，只要有可能，总是使用 `std::size()` 函数；当然，也可以使用 `std::array<T>` 对象

## 用浮点数控制 for 循环

前面使用 `for` 循环的例子都是使用整型变量控制循环，但通常还可以使用自己喜欢的变量控制循环。下面的代码段就使用了浮点数控制循环

```cpp
for (double radius {2.5}; radius <= 20.0; radius += 2.5)
{
    std::cout << std::format("radius = {:4.1f}, area = {:7.2f}\n", radius, std::numbers::pi * radius * radius);
}
```

这个循环用 `radius` 变量控制，其类型是 `double`。它的初始值是 $2.5$，每次循环迭代时都会递增，直到其值超过 $20.0$ 为止，此时循环结束。循环语句利用标准公式 $\pi r^2$，根据 `radius` 变量的当前值计算圆的面积。

::: warning

在使用浮点变量控制 `for` 循环时应小心。小数部分的值可能不能用二进制浮点数准确表示，这会导致一些意想不到的负面效果

:::

## 更复杂的 for 循环控制表达式

在第一个 `for` 循环控制表达式中可以定义并初始化多个给定类型的变量。各个变量之间使用逗号隔开

```cpp
for (unsigned long long n {1}, sum {}, factorial {1}; n <= limit; ++n)
{
    sum += n;  // 1 ... limit 的和
    factorial *= n; // limit!
}
```

注意：在确定变量 `limit` 的值时，请不要使用太大的值，因为阶乘增长会非常快，很容易超出 `unsigned long long` 整数变量的范围。

### 逗号运算符

尽管逗号看起来像是一个分隔符，但实际上它是一个二元运算符。它可以把两个表达式组合到一个表达式中，组合后的表达式的结果是其右操作数的结果。也就是说，只要能编写表达式，就可以编写逗号隔开的一组表达式

```cpp
int i {1};
int value1 {1};
int value2 {1};
int value3 {1};

std::cout << (value1 += ++i, vlaue2 += ++i, value3 += ++i) << std::endl;  // [!code highlight]
// value1 += ++i  ==> i = 2; value1 = 3
// value2 += ++i  ==> i = 3; value2 = 4
// value3 += ++i  ==> i = 4; value3 = 5
```

## 基于范围的 for 循环

基于范围的 `for` 循环迭代一个值范围中的所有值。这会出现一个问题：范围是什么？数组是一个元素范围，字符串是一个字符范围。标准库提供的容器都是范围。基于范围的 `for` 循环的一般形式如下

```cpp
for (range_declaration: range_expression)
{
    // 循环语句或语句块
}
```

`range_expression` 标识数据源的范围，`range_declaration` 标识了一个变量，它会被依次赋予范围中的每个值，在每次迭代时都会赋予一个新值。例如

```cpp
int values [] {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};

int total {};

for (int x : values)
{
    total += x;
}
```

变量 `x` 在每次迭代中都会被赋予 `values` 数组中的一个值。它会依次被赋予 $2$、$3$、$5$ 等，因此，循环会在 `total` 中累计 `values` 数组中的所有元素的和。变量 `x` 是循环的局部变量，在循环的外部不存在。

**初始化列表本身就是一个有效的范围**，所以甚至可以将前面的代码更简洁的编写如下代码

```cpp
int total {};

for (int x : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29})
{
    total += x;
}
```

当然，编译器知道 `values` 数组中的元素的类型，所以可以编写如下循环，让编译器确定变量 `x` 的类型

```cpp
for (auto x : values)
{
    total += x;
}
```

::: tip

使用 `auto` 关键字会让编译器推断 `x` 的类型。`auto` 关键字在基于范围的 `for` 循环中非常常见。这是迭代数组或者其他范围中所有元素的一种非常好的方式。不需要知道元素的个数，循环机制会自动确定

:::

注意范围中的值被赋予范围变量 `x`，这表示不能通过修改 `x` 的值来修改 `values` 数组的元素。例如

```cpp
for (auto x : values)
{
    x += 2;  // 这只是给局部变量 x 加 2，不是给数组元素加 2
}
```

存储在 `x` 中的值会被下一次迭代时被 `values` 数组中的下一个元素值覆盖。在 [第六章 指针和引用](006-指针和引用.md) 中介绍如何使用一个引用变量修改基于范围的 `for` 循环中的值

## while 循环

`while` 循环使用逻辑表达式来控制循环体的执行。该循环的一般形式如下

```cpp
while (condition)
{
    // 循环语句或语句块
}
// 下一条语句
```

下图描述了 `while` 循环的逻辑的执行流程

![1763424983237-d496c5210f1a4abf795cdddfb6e10f6c.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1763424983237-d496c5210f1a4abf795cdddfb6e10f6c.png)

在每次循环迭代开始时计算 `condition` 表达式的值。如果 `condition` 的值是 `true`，就继续执行循环体；如果 `condition` 的值为 `false`，就退出循环执行下一条语句。例如

```cpp{19-24} title="sum_factorial.cpp"
#include <iostream>
#include <format>

int main()
{
    unsigned int limit {};
    std::cout << "This program calculates n! and the sum of the integers "
            << "up to n for values 1 to limit.\n";
    std::cout << "What upper limit for n would you like? ";
    std::cin >> limit;

    const auto table_format = "{:>8} {:>8} {:>20}\n"
    std::cout << std::format(table_format, "integer", "sum", "factorial");

    unsigned int n {};
    unsigned int sum {};
    unsigned long long factorial {1ULL};

    while (++n <= limit)
    {
        sum += n;
        factorial *= n;
        std::cout << std::format(table_format, n, sum, factorial);
    }
}
```

::: tip

任何 `for` 循环都可以写为等价的 `while` 循环。例如 `for` 循环的一般形式如下

```cpp
for (initialization; condition; iteration)
{
    // 循环体
}
```

使用 `while` 循环的等价形式为

```cpp
{
    initialization;
    while (condition)
    {
        // 循环体
        iteration
    }
}
```

需要把 `while` 循环放在一个额外的花括号中，从而模拟在原来 `for` 循环中，`initialization` 代码中声明的变量的作用域为该 `for` 循环

:::

## do-while 循环

`do-while` 循环与 `while` 循环类似，区别在于：**`do-while` 循环的循环条件是在循环执行后才检查的**，而不是在开始时检查，所以 **循环语句至少执行一次**。`do-while` 循环的一般形式如下

```cpp
do {
    // 循环体
} while(condition);  // 注意：这里必须有个分号

// 下一条语句
```

`do-while` 循环的循环条件之后必须有一个分号。如果遗漏了它，程序就会编译失败。下图演示了 `do-while` 语句的执行流程

![1763483485831-d6e3ebf63661c77d7ce1a5c2aa062e8f.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1763483485831-d6e3ebf63661c77d7ce1a5c2aa062e8f.png)

如果代码块总是要执行一次，也可以执行多次，那么使用 `do-while` 循环再合适不过了。如下例子：程序要计算任意多个输入值的平均值，例如温度，但不对这些值进行排序。实现无法知道要输入多少个值，但是程序可以假定至少会输入一个值，否则程序根本不用执行。此时，最好使用 `do-while` 循环

```cpp title="average.cpp"
#include <iostream>

int main()
{
    char reply {};
    int count {};
    double temperature {};
    double total {};

    do {
        std::cout << "Enter a temperature reading: ";
        std::cin >> temperature;
        total += temperature;
        ++count;

        std::cout << "Do you want to enter another? (y/n): ";
        std::cin >> reply;
    } while (std::tolower(reply) == 'y');
    std::cout << "The average temperature is " << total / count << std::endl;
}
```

::: warning

警告: 不要在 `while` 循环的 `while ()` 后面加上分号

```cpp
while (condition) ;  // 这个分号是一个空语句，这样会导致 while 执行空语句，body 变为 while 循环后的语句
    body
```

如果在 `while` 循环的 `while ()` 后面加上分号，会导致 `while` 执行空语句，`body` 变为 `while` 循环的后的下一条的语句

:::

## 嵌套的循环

可以把一个循环放在另一个循环的内部。实际上，可以在循环中嵌套多次，直到解决问题为止。而且，嵌套的循环可以是任何类型：如有必要，可以在 `while` 循环中嵌套 `for` 循环，再把 `while` 循环嵌套在 `do-while` 循环中，最后把 `do-while` 循环嵌套在基于范围的  `for` 循环中。它们能够以任何方式混合在一起。

嵌套的循环常应用于数组，但它们也有其他用途。下面的示例程序用于 **输出乘法表**，这是嵌套循环的一个非常有用的示例。乘法表如下所示

```shell
1 * 1 = 1
1 * 2 = 2  2 * 2 = 4
1 * 3 = 3  2 * 3 = 6   3 * 3 = 9
1 * 4 = 4  2 * 4 = 8   3 * 4 = 12  4 * 4 = 16
1 * 5 = 5  2 * 5 = 10  3 * 5 = 15  4 * 5 = 20  5 * 5 = 25
1 * 6 = 6  2 * 6 = 12  3 * 6 = 18  4 * 6 = 24  5 * 6 = 30  6 * 6 = 36
1 * 7 = 7  2 * 7 = 14  3 * 7 = 21  4 * 7 = 28  5 * 7 = 35  6 * 7 = 42  7 * 7 = 49
1 * 8 = 8  2 * 8 = 16  3 * 8 = 24  4 * 8 = 32  5 * 8 = 40  6 * 8 = 48  7 * 8 = 56  8 * 8 = 64
1 * 9 = 9  2 * 9 = 18  3 * 9 = 27  4 * 9 = 36  5 * 9 = 45  6 * 9 = 54  7 * 9 = 63  8 * 9 = 72  9 * 9 = 81
```

我们需要编写程序输出上述乘法表，要求每列之间的最小间隙是相同。下面给出如下示例代码

```cpp title="multiply_table.cpp"
#include <iostream>
#include <format>


int main()
{
    for (int i = 1; i < 10; ++i) {
        for (int j = 1; j <= i; ++j) {
            if (j < 2)
                std::cout << std::format("{} * {} = {:<3}", j, i, i * j);
            else
                std::cout << std::format("{} * {} = {:<4}", j, i, i * j);
        }
        std::cout << std::endl;
    }
}
```

`for` 循环语句是最容易进行嵌套的。理解 `for` 循环的嵌套，对于其他循环的相互嵌套是同样的

## 跳过循环迭代

有时需要 **跳过循环迭代**，直接开始下一次循环。在需要跳过循环迭代的代码位置输入语句 `continue;`，当循环执行到该语句时，就会立即跳到当前迭代的末尾。只要循环控制表达式允许，程序就会执行下一次迭代。

下面我们用一个示例程序演示 `continue` 语句。假定要输出一个字符表以及对应的十六进制和十进制格式的字符代码。当然，不希望输出没有符号表示的字符(非打印字符)，例如制表符和换行符，这些字符会使结果变得混乱。所以，该示例程序只输出可打印字符

```cpp title="character.cpp"
#include <iostream>
#include <format>
#include <cctype>


int main() {
    // 宽度 11 居中对齐
    constexpr auto head_format = "{:^11}{:^11}{:^11}\n";

    std::cout << std::format(head_format, "Character", "Hexadecimal", "Decimal");

    char ch {};
    do {
        // 字符原样 字符的十六进制编码 字符的十进制编码 输出
        constexpr auto body_format = "{0:^11}{0:^11X}{0:^11d}\n";
        // 不是可打印字符
        if (!std::isprint(ch))
            continue;
        std::cout << std::format(body_format, ch);
    } while (ch++ < 127);
}
```

## 循环中断

有时候需要 **提前终止循环**。当循环没有必要继续执行代码时，就可以使用 `break` 语句提前终止循环。`break` 语句的作用与 [第四章 决策#switch 语句](./004-决策.md#switch-语句) 中的相同。如果在循环中执行 `break` 语句，循环就会立即终止，程序将继续执行循环语句后面的语句。**break 语句在无限循环(indefinite loop)中经常使用**

### 无限循环

无限循环是可以永远执行下去，也称为 **死循环**。例如，如果省略 `for` 循环语句中的第二个控制表达式，循环就没有停止机制了。除非在循环体中采用某种方式退出循环，否则循环会无休止的运行下去

无限循环确实与一些非常有用的应用场景。例如，**监视某种告警指示器程序**，或者在工业园区中收集传感器的数据，有时候就是用无限循环编写的。**在事前不知道需要迭代多少次**时，也可以使用无限循环，例如读取输入数据量可变时。在这些情况下，**退出循环的机制应该在循环体中编写**，而不应该在循环控制表达式中设置

在 `for` 无限循环的最常见形式中，所有的循环控制表达式都被省略了

```cpp
for ( ; ; )
{
    ...
    // 满足条件时退出
    if (condition)
        break; // 或者 return;
}
```

::: tip

在 C/C++ 中，`for` 循环即使没有控制表达式，其中的分号(`;`)也是必须要要保留的。

:::


也可以使用下面的 `while` 无限循环

```cpp
while (true)
{
    ...
    if (condition)
        break; // 或者 return;
}
```

在编写无限循环时，通常使用 `for` 循环或 `while` 循环。当然，`do-while` 循环也可以执行无限循环，但是形式不太好用，也不会经常使用它。无限循环的终止方式之一就是使用 `break` 语句

::: tip

一般而言，应该谨慎使用无限循环，甚至是 `break` 语句。它们有时候被认为是不良的编程风格。尽可能将决定循环合适结束的条件放在循环控制表达式中。

:::

在下面的一个示例中，使用 `while` 无限循环按升序对数组内容进行排序

```cpp {41-47} title="sort.cpp"
#include <iostream>
#include <format>

int main()
{
    constexpr size_t size{ 1000 };  // 数组大小
    double x[size]{};  // 数组
    size_t count{};  // 元素个数

    while (true)
    {
        double input{};
        std::cout << "Enter a non-zero value, or 0 to end: ";
        std::cin >> input;
        if (input == 0.0)
        {
            break;
        }
        x[count++] = input;
        if (count == size)
        {
            std::cout << "Sorry, I can only store " << size << " values.\n";
            break;
        }
    }

    if (count == 0)
    {
        std::cout << "Noting to sort ..." << std::endl;
        return 0;
    }
    std::cout << "Starting sort ..." << std::endl;

    while (true)
    {
        bool swapped{ false };  // 变为 true 时，有元素交换

        for (size_t i{}; i < count - 1; i++)
        {
            // 前一个比后一个小
            if (x[i] > x[i + 1])
            {
                const auto temp = x[i];
                x[i] = x[i + 1];
                x[i + 1] = temp;
                swapped = true;
            }
        }
        // swapped 为 false 表明没有元素发生交换，因此退出循环
        if (!swapped)
        {
            break;
        }
    }
    std::cout << "Your data in ascending sequence: " << std::endl;
    const size_t perline{ 10 };  // 每行输出 perline 个元素
    size_t n{}; // 当前行输出的元素个数
    for (size_t i{}; i < count; ++i)
    {
        std::cout << std::format("{:8.1f}", x[i]);
        if (++n == perline)
        {
            std::cout << std::endl;
            n = 0;
        }
    }
    std::cout << std::endl;
    return 0;
}
```

在上述代码中，我们在 `while` 无限循环中排序元素。对数组元素值排序是在嵌套的 `for` 循环中完成的，该 `for` 循环迭代连续两个元素，检查它们的是否按升序排列。如果两个元素的值不按升序排列，则交换它们的值，使它们正确排序。布尔变量 `swapped` 用于记录在每次执行嵌套的 `for` 循环时是否有数据交换。如果没有数据交换，就证明所有的元素都是排序好的，此时，就应该结束 `while` 无限循环

::: tip

这种排序方法被称为 **冒泡排序**，因为元素逐渐冒泡到数组中正确的位置。虽然，这个排序方法不是高效的，但是用于描述嵌套循环非常有用

:::

## 使用无符号整数控制 for 循环

在 `sort.cpp` 示例代码中，它说明了使用无符号整数控制 `for` 循环的一个要点。这个示例中，检查用户是否输入了值

```cpp
if (count == 0)
{
    std::cout << "Noting to sort ..." << std::endl;
    return 0;
}
```

如果省略上述代码片段。并且用户没有输入值。换句话说，就是 `count == 0`。此时，如果执行到如下循环会发生什么呢？

```cpp
for (size_t i{}; i < count - 1; i++)
{
    // 前一个比后一个小
    if (x[i] > x[i + 1])
    {
        const auto temp = x[i];
        x[i] = x[i + 1];
        x[i + 1] = temp;
        swapped = true;
    }
}
```

如果 `count` 等于 $0$，那么 `count - 1` 的值就是 $-1$。由于 `count` 是无符号整数，编译器会将 $-1$ 的二进制表示解释为无符号整数，因此该值会非常大。即使是最快的计算机也要执行很久才能完成。然而，在我们的示例中，循环计数变量 `i` 在大于 $1000$ 时，`x[i]` 就会访问并覆盖不应该访问的内存地址

::: tip

在进入循环之前，检查 `count` 是否不为 $0$。这就是我们在 `sort.cpp` 示例代码中的解决方案。当然，我们也可以**反向遍历数组**。

:::

## 字符数组

在 C++ 中，`char` 类型的数组有两种含义。它可以是一个字符数组，每个元素存储一个字符；也可以表示一个字符串，此时，字符串中的每个字符存储在一个数组元素中，字符串的结尾用一个特定的字符串终止字符 `'\0'` 表示，该字符 `'\0'` 称为 **空字符**，用于标记字符串的结束。

::: tip

用 `'\0'` 终止的字符数组称为 C 风格字符串，用于与标准 `<string>` 模块中提供的 `string` 类型区别。

`string` 类型相比于 C 风格字符串更灵活，更便于操作。关于 `string` 类型，我们将在 [第七章 操作字符串](./007-操作字符串.md) 中介绍

:::

使用下面的语句可以定义并初始化字符数组

```cpp
char vowels[5] {'a', 'e', 'i', 'o', 'u'};
```

这不是一个字符串，而只是一个包含 $5$ 个字符的字符数组。数组的每个元素都用初始化列表中的对应字符进行初始化。与数值数组一样，如果提供的初始值少于数组的元素个数，没有显式初始化值的元素就初始化为 $0$ 的对等值，即空字符 `'\0'`

```cpp
char vowels[6] {'a', 'e', 'i', 'o', 'u'};  // 最后一个元素被初始化为 '\0'
```

当然，也可以让编译器自动将数组的大小设置初始化列表的长度

```cpp
char vowels[] {'a', 'e', 'i', 'o', 'u'};
// 等价于 char vowels[5] {'a', 'e', 'i', 'o', 'u'};
```

**可以声明一个 `char` 类型的字符数组，并用一个字符串字面量进行初始化**。例如

```cpp
char name[10] {"Mae West"};
```

这里创建了一个 C 风格字符串。由于是用一个字符串字面量初始化数组，因此应在该字符串的最后一个字符后面添加空字符，这样该数组的内容如下图所示

![1763650544441-2e381e77b75cc7a6cdd06e43817d5beb.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1763650544441-2e381e77b75cc7a6cdd06e43817d5beb.png)

也可以在用字符串初始化数组时，让编译器自动设置数组的大小。这次，数组有 $9$ 个元素；前 $8$ 个存储字符串中的字符，最后一个元素存储字符串的终止字符。

```cpp
char name[] {"Mae West"};
```

使用字符数组名可以输出存储在该数组中的字符串。例如，用下面的语句可以把 `name` 数组中的字符串写入 `cout`

```cpp
std::cout << name << std::endl;
```

::: warning

这将显示整个字符串，直到遇见字符串终止字符 `'\0'`，最后必须是 `'\0'`。否则，标准输出流会继续输出后续内存空间中存储的字符(几乎都是垃圾值)，直到语句终止字符 `'\0'` 为止

:::

::: danger

注意：只使用数组名是不能输出数值数组中的元素的。这种方法只适用于 `char` 类型的数组。而且，即使是传递给输出流的 `char` 数组，也必须用空字符结束，否则程序很容易崩溃

:::

在下面的示例程序中，分析一个 char 数组，确定其中使用了多少元音和辅音

```cpp title="vowels.cpp"
#include <iostream>

#include <cctype>

int main()
{
    constexpr int size{ 100 };  // 数组大小
    char text[size]{};
    std::cout << "Enter a line of text: " << std::endl;
    // 从标准输入中读取一行文本，包括空格
    // 注意：这里不能使用 >> 输入运算符，因为它会在遇到空格时停止读取
    std::cin.getline(text, size);
    std::cout << "You entered:\n" << text << std::endl;
    size_t vowels{};  // 元音字母个数
    size_t consonants{};  // 辅音字母个数

    for (int i{}; text[i] != '\0'; ++i)
    {
        // text[i] 是一个字母
        if (std::isalpha(text[i]))
        {
            switch (std::tolower(text[i]))
            {
            case 'a':
            case 'e':
            case 'i':
            case 'o':
            case 'u':
                ++vowels;  // 元音字母个数 +1
                break;
            default:
                ++consonants;  // 辅音字母个数 +1
                break;
            }
        }
    }
    std::cout << "Your input contained " << vowels << " vowels and "
    << consonants << " consonants." << std::endl;
    return 0;
}
```

下面是这个程序的输出

```shell
Enter a line of text:
A rich man is nothing but a poor man with money.
You entered:
A rich man is nothing but a poor man with money.
Your input contained 14 vowels and 23 consonants.
```

`char` 数组 `text` 的元素个数由 `constexpr` 变量 `size` 定义，它确定了可以存储的最大字符串长度，包括终止字符，所以最长的字符串可以包含 `size - 1` 个字符。

不能使用输入运算符(`>>`)读取输入内容，因为它不能读取包含空格的字符串，任何空白字符都会终止 `>>` 运算符的输入操作。在 `<iostream>` 模块中定义的 `cin` 流的 `getline()` 函数可以读取一系列字符。默认情况下，在读取换行 `'\n'` 后输入结束。

`getline()` 函数还有一个可选参数，它允许指定 `'\n'` 的替代字符，以表示输入结束。例如，如果输入一个星号来表示输入字符串的结束，就可以使用下面的语句

```cpp
std::cin.getline(text, size, '*');
```

这就允许输入多行文本，因为按下回车键后得到的 `'\n'` 不再终止输入操作。当然，在输入操作中，输入的总字符仍由 `size` 限制

## 多维数组

前面声明的所有数组都只需要一个索引值即可选择元素。这种数组称为 **一维数组**，因为改变一个索引就可以引用所有元素。也可以定义需要两个或者更多索引值才能访问的数组，这种数组一般称为 **多维数组**。需要两个索引值来引用元素的数组称为二维数组。需要三个索引的数组称为三维数组，以此类推

假设有一名园丁，他要记录在菜园中种植的每个胡萝卜的重量。这些胡萝卜按照三行四列的方式种植。为了记录每个胡萝卜的重量，可以声明一个二维数组

```cpp
double carrots[3][4] {};
```

上述语句定义了一个三行四列的数组，并且每个元素都初始化为 $0$。要引用 `carrots` 数组中的元素，需要两个索引值。第一个索引值指定行，取值范围是 $0 \sim 2$；第二个索引值指定列，取值范围是 $0 \sim 3$。要存储第二行第三列的胡萝卜重量，可以使用下面的语句

```cpp
carrots[1][2] = 1.5;
```

**C++ 中的多维数组本质上也是一维数组**。在内存中，`carrots` 数组的存储方式如下

![1763733687592-f0813a1e08090545ccb250dd1abf4d4f.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1763733687592-f0813a1e08090545ccb250dd1abf4d4f.png)

这些行存储在一个连续的内存块中。该二维数组实际上是一个有 $3$ 个元素的一维数组，每个一维数组都有 $4$ 个元素

在引用元素时，要使用两个索引值。第二个索引值从第一个索引值指定的行中选择元素，在内存中从一个元素遍历到下一个元素时，第二个索引值变化得较快。也可以把二维数组看做 **矩阵**，其中的元素从左到右排列，第一个索引值指定一行，第二个索引值指定一列。下图演示了这个概念

![1763734447856-d2c4a187f8679e0cab3e5c46909c94f1.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1763734447856-d2c4a187f8679e0cab3e5c46909c94f1.png)

**数组名本身引用整个数组**。注意，对于此数组，不能利用这种符号表示法显示一整行或者整个数组的内容

```cpp
std::cout << carrots << std::endl;  // 不能输出数组
```

这条语句会输出一个十六进制的整数，它是数组中第一个元素的内存地址。我们在 [第六章 指针和引用](./006-指针和引用.md) 中说明原因。`char` 数组表现形式不一样，是因为编译器假定 `char` 数组是 C 风格的字符串。

要逐行显示整个数组，可以使用下面的语句

```cpp
for (size_t i {}; i < std::size(carrots); ++i)
{
    for (size_t j {}; j < std::size(carrots[i]); j++)  // [!code highlight]
    {
        std::cout << std::foramt("{:7.3}", carrots[i][j]);
    }
    std::cout << std::endl;
}
```

### 初始化多维数组

为多维数组提供初始值的方法来源于二维数组是一维数组的数组。一维数组的初始值放在花括号中，用逗号隔开。根据这种方法，用下面的语句可以定义并初始化二维数组 `carrots`

```cpp
double carrots[3][4] {
    {2.5, 3.2, 3.7, 4.1},
    {4.1, 3.9, 1.6, 3.5},
    {2.8, 2.3, 0.9, 1.1}
}
```

因为每一行都是一个一维数组，说以每一行的初始值就包含在一对花括号中。这 $3$ 个初始化列表本身包含在一对花括号中，因为二维数组是一个一维数组的一维数组。按照这个规则，可以扩展到任意维度数组。

在上述初始化列表中，内层的第 $i$ 初始化列表对应于 `carrots[i]`。如果内层的某些初始化列表没有提供足够的元素时，缺失的元素被初始化为 $0$。例如

```cpp
double carrots[3][4] {
    {2.5, 3.2},         // 第一行 2.5  3.2  0    0
    {4.1},              // 第二行 4.1  0    0    0
    {2.8, 2.3, 0.9}     // 第三行 2.8  2.3  0.9  0
}
```

甚至可以完全省略内存初始化列表的花括号。此时，按照行主序的方式依次初始化多维数组的元素。

可以让编译器根据初始化列表决定数组的第一个维度的大小。显然，编译器只能确定多维数组的第一个维度的大小。例如

```cpp
double carrots[][4] {
    {2.5, 3.2},         // 第一行 2.5  3.2  0    0
    {4.1},              // 第二行 4.1  0    0    0
    {2.8, 2.3, 0.9}     // 第三行 2.8  2.3  0.9  0
}
```

这个数组与以前一样有三行，因为在外层的花括号中有三组花括号对。如果只有两组花括号对，这个数组就只有两行

### 多维字符符数组

可以定义任意维度的数组来存储任意类型的数据。`char` 类型的二维数组可以保存一组 C 风格字符串。在用字符串字面值初始化 `char` 类型的数组时，不需要对每行字面值加上花括号，因为字符串字面值的双引号完成了花括号的工作

```cpp
char stars[][80] {
    "Robert Redford",
    "Hopalong Cassidy",
    "Lassie",
    "Slim Pickens",
    "Boris Karloff",
    "Oliver Hardy"
};
```

这个数组有六行，因为它把六个字符串字面值作为初始值。数组的每行存储了一个字符串，其中包含一个电影明星的名字，而且为每个字符串都追加了终止字符 `'\0'`。下面通过一个例子来演示这类数组

```cpp
#include <iostream>


int main()
{
    constexpr size_t size{ 80 };
    char stars[][size]{
        "Robert Redford",
        "Hopalong Cassidy",
        "Lassie",
        "Slim Pickens",
        "Boris Karloff",
        "Oliver Hardy"
    };
    size_t choice{};
    std::cout << "Choose your favorite star! Enter a number between 1 and " << std::size(stars) << ": ";
    std::cin >> choice;

    if (choice >= 1 && choice <= std::size(stars))
    {
        std::cout << "You selected: " << stars[choice - 1] << std::endl;
    }
    else
    {
        std::cout << "Invalid choice!" << std::endl;
    }
}
```

## 变长数组

C++ 标准不允许变长数组(VLA, variable-length array)。变长数组是指在编译时不知道其大小的数组。

::: tip

在 C++ 中，数组的维数必须是一个整数类型的常量表达式(constant expression)，即在编译时就能确定其值。

:::

然而，大多数 C++ 编译器允许变长数组，因为 C99 标准支持变长数组。目前，大多数 C++ 编译器也会用于编译 C 代码。

下面的代码演示了如何使用变长数组

```cpp title="vla.cpp"
#include <iostream>
#include <format>

int main()
{
    size_t size{};
    std::cout << "Enter the number of elements: ";
    std::cin >> size;

    int height[size];  // 变长数组。注意，变长数组不能进行初始化

    size_t entered{};  // 输入的元素数量
    while (entered < size)
    {
        std::cout << "Enter a height (in inches): ";
        std::cin >> height[entered];
        if (height[entered] > 0)
        {
            ++entered;
        }
        else
        {
            std::cout << "A height must be positive - try again.\n";
        }
    }

    unsigned int total{};
    for (size_t i{}; i < entered; ++i)
    {
        total += height[i];
    }
    std::cout << std::format("The average height is {:.1f} \n", static_cast<double>(total) / entered);
}
```

::: danger

注意：这段代码不是所有编译器都能通过。因为这是具体实现的特性，而不是 C++ 标准的一部分。尽量不要使用这种依赖于具体实现的特性

:::

## 数组的替代品

C++ 标准模板库(STL, Standard Template Library) 提供了几种替代数组的容器类型，例如 `std::vector` 和 `std::array`。这些容器类型比数组更灵活，更易于使用。在后续章节中，我们将重新介绍这些容器类型及其用法，目前只是简单讨论它们的用法

`std::array<T, N>` 和 `std::vector<T>` 都是模板类(template class)，它们都定义在 `<array>` 和 `<vector>` 头文件中。`T` 是数组或向量中存储的元素类型。

### 使用 `array<T, N>` 容器

`array<T, N>` 模板在 `<array>` 模块中定义，所以必须在源文件中导入这个模块，才能使用容器类型。`array<T, N>` 容器是类型为 `T` 的 `N` 个元素的固定序列，所以它与普通数组非常像，只是类型和大小的指定方式不同。例如，下面的语句创建了一个 `array<>` 容器，它包含 $100$ 个 `double` 类型的元素

```cpp
std::array<double, 100> values{};
```

上面的语句创建了一个对象，该对象包含了 $100$ 哥 `double` 类型的元素。参数 `N` 必须指定为一个整型常量表达式，这与普通的数组一样。实际上，`std::array<double, 100>` 类型的变量在行为上与下面声明的普通变量相同

```cpp
double values[100];
```

与普通数组一样，如果创建 `array<>` 对象时没有指定初始值，则该对象中包含无效值。大部分标准库类型，包括 `std::vector<>` 和其他所有容器，总是初始化其元素为类型的零值。但是，`array<>` 比较特殊，它被专门设计来模拟普通数组，并提供普通数组不支持的操作。自然，也可以在 `array<>` 的定义中初始化其元素，就像普通数组一样

```cpp
std::array<double, 100> values {0.5, 1.0, 1.5, 2.0}; // 其余元素被初始化为 0.0
```

如果想要把所有元素都初始化为 $0$，可以使用一个空初始化器

```cpp
std::array<double, 100> values{};  // 所有元素都初始化为 0.0
```

::: tip

从 C++17 开始，允许编译器根据初始化列表来推断模板参数。例如

```cpp
atd::array values {0.5, 1.0, 1.5, 2.0}; // 推断为 std::array<double, 4>
```

要对模板参数进行推断，初始化列表就不能为空，且其中的值的类型必须相同

```cpp
std::array oopsy {};  // error: 无法推断模板参数，因为没有提供初始值
std::array mix {1, 2.5, 3};  // error: 无法推断模板参数，因为混合了 int 和 double 类型
```

:::

`std::array<>` 对象与一个成员函数 `fill()`，它可以把所有元素设置为给定的值。例如，

```cpp
values.fill(std::numbers::pi); // 把所有元素设置为 π
```

`std::array<>` 对象还提供了一个成员函数 `size()`，它返回数组中的元素个数；成员函数 `size()` 的优点是它总是知道它有多少个元素。例如，

```cpp
std::cout << "The array contains " << values.size() << " elements." << std::endl;
```

访问和修改 `array<>` 对象中的元素与访问和修改普通数组中的元素相同

```cpp
values[3] = values[2] + 2.0 * values[1];
```

下面是另一个例子，可计算 `values` 对象中所有元素的和

```cpp
double total{};
for (size_t i {}; i < values.size(); ++i)
{
    total += values[i];
}
```

与普通数组一样，`array<>` 对象也不会检查使用方括号(`[]`)的索引访问的索引值是否有效。因此，`array<>` 的成员函数 `at(index)` 会检查索引 `index` 是否超出有效范围。如果索引无效，`at()` 函数会抛出一个异常。换句话说，`values.at(i)` 等价于 `values[i]`，但是 `at(i)` 函数会检查索引值 `i` 是否合法

```cpp
double total{};
for (size_t i {}; i <=values.size(); ++i)
{
    total += values.at(i);  // 当 i == values.size() 时抛出异常 std::out_of_range
}
```

`array<>` 模板还提供了比较方便的函数，用于访问第一个元素和最后一个元素。如果有一个 `std::array<>` 类型的对象 `values`，则 `values.front()` 等价于 `values[0]`，而 `values.back()` 等价于 `values[values.size() - 1]`

对于类型相同且大小相同的两个 `std::array<>` 对象，可以使用关系运算符进行比较。例如，下面的语句检查 `values1` 和 `values2` 是否相等

```cpp
std::array these {1.0, 2.0, 3.0, 4.0};
std::array those {1.0, 2.0, 3.0, 4.0};
std::array them {1.0, 2.0, 3.0, 5.0};

if (these == those)
    std::cout << "these and those are equal." << std::endl;
if (these != them)
    std::cout << "these and them are not equal." << std::endl;
if (these < them)
    std::cout << "these is less than them." << std::endl;
if (them > these)
    std::cout << "them is greater than these." << std::endl;
```

::: tip

这会对容器中的元素逐个进行比较。如果 `==` 返回 `true`，表明所有对应元素都必须相同

注意：**对于普通数组，不允许这样比较**。
:::

只要两个 `std::array<>` 容器存储相同数量的相同类型的元素，就可以将其中一个对象赋值给另一个对象

```cpp
them = those;  // 把 those 的内容复制到 them 中
```

::: danger

`std::array<>` 对象可以存储除了普通数组之外的任何类型的元素，包括其他 `std::array<>` 对象

:::

### 使用 `vector<T>` 容器

`std::vector<>` 容器是一个序列容器。类似于 `std::array<>`，但是功能更强大。`std::vector<>` 对象可以 **动态调整其容量大小**，而 `std::array<>` 对象的大小在创建时就固定了。`std::vector<>` 模板定义在 `<vector>` 头文件中，所以必须导入该模块，才能使用 `std::vector<>` 容器类型

::: tip

换句话说就是，`std::verctor<>` 对象可以在程序运行时动态调整其大小，而 `std::array<>` 对象的大小在编译时就已经确定了。

:::

下面的示例代码中创建了一个 `vector<>` 容器，以存储 `double` 类型的元素

```cpp
std::vector<double> values; // 创建一个空的 vector 容器
```

这里没有给元素分配任何空间，所以在添加第一个数据项时，需要动态分配内存。使用容器对象的 `push_back(value)` 成员函数可以添加元素。例如

```cpp
values.push_back(3.14); // 添加第一个元素
```

`push_back()` 函数在已有元素的后面添加传递为参数的值（这里是 `3.14`），作为一个新元素。由于此时容器还没有元素，这是第一个元素，因此需要分配内存空间。

`std::vector<>` 可以预定义元素的个数来初始化。例如，下面的语句创建了一个包含 $100$ 个 `double` 类型元素的 `vector<>` 容器

```cpp
std::vector<double> values(100);  // 创建一个 vector 容器对象，包含 100 个元素
```

`std::vector<>` 总是会初始化元素，默认情况下初始化为类型的零值。如果不喜欢，还可以指定额外的参数，来设置元素的初始值

```cpp
std::vector<double> values(100, 3.14);
// 创建一个 vector 容器对象，包含 100 个元素，每个元素初始化为 3.14
```

创建 `std::vector<>` 的另一种初始化方式是使用初始化列表指定初始值

```cpp
std::vector<double> values {0.5, 1.0, 1.5, 2.0};
// values 包含 4 个元素，分别初始化为 0.5、1.0、1.5 和 2.0
```

从 C++17 开始，也可以让编译器根据初始化列表推断模板参数

```cpp
std::vector primes {2, 3, 5, 7, 11, 13}; // 推断为 std::vector<int>
std::vector values(20, 99L);  // 推断为 std::vector<long>
```

::: warning

请注意：**圆括号初始化(函数式初始化)** 和 **花括号初始化(统一初始化)** 是有本质区别的。尤其在标准模板库(STL)中，圆括号初始化通常表示调用构造函数，而花括号初始化通常表示使用初始化列表进行初始化

换句话说，当使用花括号来初始化 `vector<>` 对象时，编译器总是把它解释为一个初始值序列。

:::

可以向使用 `array<>` 对象一样使用 `vector<>` 对象。例如

```cpp
values[0] = std::numbers::e;  // 设置第一个元素为 e
values[1] = 5.0;         // 设置第二个元素为 5.0
values[2] = 2.0 * values[0] * values[1];  // 设置第三个元素为 2e
```

`vector<>` 的索引从 $0$ 开始，与普通数组一样。使用方括号中的索引 **总是可以引用已有的元素，但是不能用这种方式创建新元素**。

想要向 `vector<>` 对象添加新元素，必须使用 `push_back()` 函数。该函数会在已有元素的末尾新添加一个元素。例如，下面的代码向 `values` 容器添加三个新元素

```cpp
values.push_back(3.14);  // 添加新元素 3.14
values.push_back(1.59);  // 添加新元素 1.59
values.push_back(2.65);  // 添加新元素 2.65
```

想要从 `vector<>` 容器中删除最后一个元素，可以使用 `pop_back()` 函数。例如，下面的代码删除 `values` 容器中的最后一个元素

```cpp
values.pop_back();  // 删除最后一个元素
```

`vector<>` 与 `array<>` 基本上是等价的。它们的差异在与哪里呢？首先，`vector<>` 对象可以动态调整其大小，而 `array<>` 对象的大小在创建时就固定了。其次，`vector<>` 没有 `fill()` 成员函数。但是，它提供了 `assign()` 成员函数，可以用来重新初始化 `vector<>` 对象中的元素

```cpp
std::vector numbers(20, 99L); // std::vector<long>，包含 20 个元素，每个元素初始化为 99L
numbers.assign(10, 3L);  // 重新初始化 numbers 对象，现在包含 10 个元素，每个元素初始化为 3L
numbers.assign({99L, 20L}); // 重新初始化 numbers 对象，现在包含 2 个元素，分别初始化为 99L 和 20L
```

从 C++20 标准起，标准库中提供了一个函数 `std::erase()`，它可以删除 `vector<>` 容器中的指定元素。例如，下面的代码删除 `numbers` 容器中的所有值为 $3$ 的元素

```cpp
std::vector numbers {1, 2, 3, 4, 3, 5, 3};

std::erase(num)
```

## 练习

编写一个程序，输出从 $1$ 开始到用户输入的数字之间所奇数的平方

::: details 示例程序

```cpp title="odd_squares.cpp"
// odd_sum.cpp
// 计算从 1 到用户输入数之间的所有奇数的平方

#include <iostream>
#include <format>

int main()
{
    unsigned int end{};
    std::cout << "Enter a number: ";
    std::cin >> end;

    constexpr auto head_template{ "{:^11}\t{:^11}\n" };
    constexpr auto body_template{ "{:^11}\t{:^11}\n" };

    std::cout << std::format(head_template, "odd", "odd ** 2");
    for (unsigned int number{1}; number < end; ++number)
    {
        if (number & 0x01)  // 奇数
        {
            std::cout << std::format(body_template, number, number * number);
        }
    }
    return 0;
}
```

:::

---

创建一个程序，使用 `while` 循环累加用户输入的数字的整数和。在每次迭代后，询问用户是否完成输入。最后输出所有数字的总和和浮点类型的平均值

::: details 示例程序

```cpp title="sum_average.cpp"
#include <iostream>

int main()
{
    int total{};
    unsigned int count{};

    while (true)
    {
        int value{};
        char ch{};
        std::cout << "Enter a integer number: ";
        std::cin >> value;
        total += value;
        ++count;

        std::cout << "Whether the input is complete(y/n): ";
        std::cin >> ch;
        if (std::tolower(ch) == 'y')
        {
            break;
        }
    }
    std::cout << "total is " << total << "\naverage is " << static_cast<double>(total) / count << std::endl;
}
```

:::

---

创建一个程序，使用 `do-while` 循环计算用户在一行上输入的空白字符的个数。在第一次遇到输入的 `#` 字符是，停止计数

```cpp title="count_blanks.cpp"
#include <iostream>
#include <cctype>

int main()
{
    constexpr size_t size{ 100 };
    char line[size]{};
    std::cout << "Please entered a line: \n";
    std::cin.getline(line, size, '#');

    size_t i{};
    size_t count_blank{};
    do {
        // 非空白字符
        if(!std::isspace(line[i]))
        {
            ++count_blank;
        }
    } while (line[i++]);

    std::cout << "line '" << line << "' has non-blank char number is " << count_blank << std::endl;;
    return 0;
}
```

---

生成斐波拉契数列的前 $93$ 项

::: details 示例程序

```cpp title="fibonacci.cpp"
#include <iostream>
#include <format>
#include <array>

int main()
{
    const size_t size{ 93 };
    std::array<unsigned long long, size> fib{1, 1};
    std::cout << "sizeof(unsigned long long): " << sizeof(unsigned long long) << std::endl;
    // 计算数组
    for (size_t i{ 2 }; i < size; ++i)
    {
        fib[i] = fib[i - 1] + fib[i - 2];
    }
    for (auto x : fib)
    {
        std::cout << std::format("{:>20}\n", x);
    }
}
```

:::

思考一下，为什么只计算前 $93$ 项呢？在 C++ 中，整数类型 `unsigned long long` 是尺寸最大的整数类型，能表示的最大整数是 $2^{64} - 1 = 18446744073709551615$。由于斐波拉契数列数量增长非常快，到第 $93$ 项时，其值为 $12200160415121876738$，已经接近该类型的最大表示范围。
