---
title: 决策
createTime: 2025/11/13 22:09:25
permalink: /cppstudy/0sipt878/
tags:
  - C/C++
---

**决策** 是任何计算机程序设计语言的基础。决策会根据数据值的比较结果来改变程序中指令的执行顺序。

## 比较数据值

要做成决策，需要一种比较机制，而比较有几种类型。例如，“交通信号灯是红色，则停车” 这种决策涉及 **相等比较**；“如果车速超过限速值，就减速” 这种决策涉及另一种关系：检查车速是否 **大于** 当前的限速值。这两种类型的比较是类似的，它们都会得到 **真或假** 两个值中的一个

使用 C++ 两个新的运算符集就可以比较数据值，即 **关系运算符** 和 **相等运算符**。下表列出了用于比较两个值的 $6$ 个运算符

| 运算符  | 描述  |     | 运算符  | 描述    |
| ---- | --- | --- | ---- | ----- |
| `<`  | 小于  |     | `<=` | 小于或等于 |
| `>`  | 大于  |     | `>=` | 大于或等于 |
| `==` | 等于  |     | `!=` | 不等于   |

这些运算符都是比较两个值，得到 `bool`(布尔)类型的值。`bool` 类型的值只有两个：`true` 和 `false`。注意：在 C++ 中，`true` 和 `false` 都是关键字，也是 `bool` 类型的字面量，有时称为布尔字面值

创建 `bool` 类型的变量的方法与其他基本类型一样，例如

```cpp
bool isValid {true}; // 定义并初始化 true
```

这条语句定义了一个变量 `isValid` 并且把它初始化为了 `true`。如果使用空花括号 `{}` 初始化 `bool` 类型的变量，其初始值就是 `false`

```cpp
bool correct {}; // 定义并初始化 false
```

假定两个整型变量 `i` 和 `j` 的值分别为 $10$ 和 $5$。在下面表达式中使用它们

```cpp
i > j    i != j    j > -8    j <= j + 15
```

这些表达式的计算结果都是 `true`。注意，最后一个表达式 `j <= j + 15` 中，`j + 15` 要先计算，因为运算符 `<=` 的优先级低于运算符 `+`

::: tip

关系运算符 `<` `>` `<=` `>=` 的优先级低于算术运算符，并且相关性都是左相关的。相等运算符 `==` 和 `!=` 的优先级低于关系运算符，相关性也是左相关

:::

也可以在 `bool` 类型的变量中存储这些表达式的值。例如

```cpp
isValid = i > j; // 如果 i > j, 则变量 isValid 的值是 true；否则，就是 false
```

也可以对 `char` 类型的变量进行比较

```cpp
char first {'A'};
char last {'Z'};

// 示例表达式
first < last    'E' < last    first != last
```

::: warning

注意：字符类型的变量比较的是字符的编码值

:::

输出 `bool` 类型的值与输出其他基本类型的值一样，下面的例子说明了它们默认的工作方式

```cpp
#include <iostream>
using namespace std;

int main()
{
    char first {};
    char second {};
    cout << "Enter a character: ";
    cin >> first;
    cout << "Enter a second character: ";
    cin >> second;
    cout << "The value of the expression " << first << '<' << second << " is " << (first < second) << endl;
    cout << "The value of the expression " << first << "==" << second << " is " << (first  == second) << endl;
    return 0;
}
```

这个程序的输出结果如下所示

```shell
Enter a character:?
Enter a second character:H
The value of the expression ?<H is 1
The value of the expression ?==H is 0
```

::: warning

将比较表达式使用圆括号括起来是必不可少的，否则编译器不能正确解释该语句。从上面的输出结果可以看出

+ 值 `true` 显示为 $1$

+ 值 `false` 显示为 $0$

这是 `true` 和 `false` 的默认表示

:::

如果需要让 `std::cout` 输出 `true` 或 `false`，可以使用 `std::boolalpha`

```cpp
#include <iomanip>

cout << std::boolalpha << "The value of the expression " << first << '<' << second << " is " << (first < second) << endl;
```

另外，使用 `std::format()` 格式化字符串时，默认情况下，对于 `bool` 类型会输出 `true` 和 `false`

```cpp
#include <format>

cout << format("The value of the expression {} == {} is {}", first,  second , (first  == second)) << endl;
```

### `<=>` 运算符

C++20 新增量一种用来比较值的运算符：**三向比较运算符 `<=>`**。在某种意义上，`<=>` 的行为就像把 `<` `==` 和 `>` 三种运算符组合到了一起。简单来说，表达式 `a <=> b` 用于判断 `a` 是否小于、等于或大于 `b`。让我们来看一个示例，理解 `<=>` 运算符的执行逻辑

```cpp
#include <compare>
#include <format>
#include <iostream>
using namespace std;

int main()
{
    int value;
    cout << "Please enter a number: ";
    cin >> value;

    // 比较 value 是否小于、等于或大于 0
    strong_ordering ordering {value <=> 0};
    // 想要获得 <=> 运算符的结果，将 ordering 与 std::strong_ordering::less std::strong_ordering::greater std::strong_ordering::equal 进行比较
    cout << format("value < 0: {}", ordering == strong_ordering::less);
    cout << format("value > 0: {}", ordering == strong_ordering::greater);
    cout << format("value == 0: {}", ordering == strong_ordering::equal);
    return 0;
}
```

::: tip

对于整数操作数，运算符 `<=>` 计算为 `std::strong_ordering` 类型的一个值，这个类型大部分情况下用作枚举类型，其值可能取值为 `less` `greater` 和 `equeal`。根据 `ordering` 的值，可以判断 `value` 相对于数字 $0$ 的顺序。

:::

使用 `<=>` 运算符得到结果的类型根据操作数的类型决定。下表显示了三向比较运算符可以使用的 $3$ 种类型

| 类型                          | 描述                      | 可用枚举值                                                 |
| --------------------------- | ----------------------- | ----------------------------------------------------- |
| `std::strong_ordering`(全序)  | 对于整数和指针类型，`<=>` 返回该类型的值 | `less(小于)` `greater(大于)` `equal(相等)` `equivalent(等效)` |
| `std::partial_ordering`(偏序) | 对于浮点类型，`<=>` 返回该类型的值    | `less` `greater` `equivalent` `unordered(无序)`         |
| `std::weak_ordering`(弱序)    | 对于用户自定义类型，`<=>` 返回该类型的值 | `less` `greater` `equivalent`                         |

请注意：对于标准类型执行三向比较运算符，永远不会得到 `std::weak_ordering` 类型。对于相等性(`equal`) 而言，意味着**可替代性**；而等效性(`equivalence`) 则没有这种含义。可替代性意味着，如果 `a == b` 为 `true`，那么对于任何函数 `f(a) == f(b)` 也必须为 `true`。然而，对于浮点数 `-0.0` 与 `+0.0`，尽管 `-0.0 == +0.0`，但是 `signbit(-0.0) != signbit(+0.0)`；换句话说，`-0.0` 与 `+0.0` 几乎相等，但是不完全相等

::: tip

`std::strong_ordering::equivalent` 与 `std::strong_ordering::equal` 完全等效。建议使用 `std::strong_ordering::equal`，因为它更好地表达了全序语义

:::

`std::strong_ordering` 类型的值可以隐式转换为 `std::weak_ordering` 和 `std::partial_ordering`；而 `std::weak_ordering` 类型的值可以隐式转换为 `std::partial_ordering`。但是，`std::partial_ordering` 类型的值被转换为其他两种类型

此外，C++ 还提供了命名的比较函数用于获取三向比较运算符(`<=>`) 的结果。下表列出了在 `<compare>` 模块中定义命名函数

| 命名比较函数           | 描述                 |
| ---------------- | ------------------ |
| `std::is_lt()`   | `a < b` 返回 `true`  |
| `std::is_gt()`   | `a > b` 返回 `true`  |
| `std::is_eq()`   | `a == b` 返回 `true` |
| `std::is_neg()`  | `a != b` 返回 `true` |
| `std::is_lteq()` | `a <= b` 返回 `true` |
| `std::is_gteq()` | `a >= b` 返回 `true` |

## if 语句

如果给定的条件是 `true`，那么基本的 `if` 语句允许程序执行一个语句或语句块，如下图所示

![1762873838126-f3334437b97c299b05e9dbab81b24a4d.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1762873838126-f3334437b97c299b05e9dbab81b24a4d.png)

下面是 `if` 语句的一个简单例子，它测试 `char` 类型变量 `letter` 的值

```cpp
if (letter == 'A')
    std::cout << "The first capital, alphabetically speaking.\n";
    // 仅当 letter 为 'A' 是执行

std::cout << "The statement always executes.\n";  // 任何时刻都执行
```

如果 `letter` 的值是 `'A'`，则表达式 `letter == 'A'` 的值为 `true`，则上述代码段输出内容如下

```shell
The first capital, alphabetically speaking.
The statement always executes.
```

如果 `letter` 的值不是 `'A'`，就只输出第二行语句。要测试的条件放在关键字 `if` 后面的圆括号中。我们采用的约定是在 `if` 和圆括号之间加上空格

`if` 之后的语句被缩进，表示只有在条件为 `true` 时才执行。对于编译器来说，语句的缩进不是必要的，但是这种缩进有助于理解 `if` 语句。有时，简单的 `if` 语句还可以写在一行上，如下所示

```cpp
if (letter == 'A') std::cout << "The first capital, alphabetically speaking.\n";
```

::: warning
注意：不要在 `if` 语句的条件后面直接添加分号(`;`)。在 C++ 中，一个分号(`;`)也是一条语句，称为 **空语句**。这样，C++ 编译器就不会对发出错误提醒

```cpp
if (letter == 'A');
    std::cout << "The first capital, alphabetically speaking.\n";

std::cout << "The statement always executes.\n";
```

上述代码无论在何种条件下，都会有两条输出。
:::

如果在 `if` 条件为 `true` 时，要执行多条语句，那么就必须使用花括号(`{}`) 将多条语句组合成一个语句块。例如，如果 `letter` 的值是 `'A'` 时，就改变它的值

```cpp
if (letter == 'A')
{
    std::cout << "The first capital, alphabetically speaking.\n";
    letter = 'a';
}
std::cout << "The statement always executes.\n";
```

如果没有花括号，就只有第一条语句是 `if` 块的内容。语句 `letter = 'a';` 始终被执行。注意，语句块中的每条语句的最后都有一个分号，而在块结束的右花括号后面没有分号。

如果将 `true` 转换为整数类型，结果就是 $1$；`false` 转换为整数类型，结果就是 $0$。还可以把数值类型转换为 `bool` 类型。$0$ 会转换为 `false`，而非 $0$ 会转换为 `true`。如果上下文需要一个 `bool` 类型的值，但是得到的确实一个数值类型，编译器就会执行隐式类型转换，将数值类型的值转换为 `bool` 类型。这个特性在 `if` 语句非常重要。例如

```cpp
#include <iostream>


int main()
{
    std::cout << "Enter an integer between 50 and 100: ";
    int value {};
    std::cin >> value;

    // value 不为 `0` 就会执行 if 语句块
    if (value)
    {
        std::cout << "You have entered a value that is different from zero." << std::endl;
    }

    // value < 50 就会执行 if 语句块
    if (value < 50)
    {
        std::cout << "The value is invalid - it is less than 50." << std::endl;
    }

    // value > 100 就会执行 if 语句块
    if (value > 100)
    {
        std::cout << "The value is invalid - it is greater than 100." << std::endl;
    }
    // 无论如何都会执行
    std::cout << "You entered " << value << std::endl;
    return 0;
}
```

如果输入 `value` 在 $50 \sim 100$ 之间，输出的内容如下

```shell
Enter an integer between 50 and 100:89
You have entered a value that is different from zero.
You entered 89
```

如果输入 `value` 在 $50 \sim 100$ 之外，输出内容如下

```shell
Enter an integer between 50 and 100:49
You have entered a value that is different from zero.
The value is invalid - it is less than 50.
You entered 49
```

### 嵌套的 if 语句

在 `if` 语句中条件为 `true` 时才执行的语句本身也可以是 `if` 语句，这种情况下称为 **嵌套的 `if` 语句**。只有在外层 `if` 语句的条件测试为 `true` 时，才会测试内层 `if` 语句的条件

```cpp
#include <iostream>


int main()
{
    char letter {};
    std::cout << "Enter a letter: ";
    std::cin >> letter;

    if (letter >= 'A')
    {
        if (letter <= 'Z')
        {
            std::cout << "You entered an uppercase letter." << std::endl;
            return 0;
        }
    }

    if (letter >= 'a')
    {
        if (letter <= 'z')
        {
            std::cout << "You entered a lowercase letter." << std::endl;
            return 0;
        }
    }
    std::cout << "You didn't enter a letter." << std::endl;
    return 0;
}
```

上述代码中执行依赖于对字符编码的两个假设

1. 字母 `A ~ Z` 用一组连续的编码表示，其中 `'A'` 最小
2. 所有大写字母都在 `A ~ Z` 的范围内

对于某些区域的字符编码而言，假设2 是不成立的。为了避免在代码中依赖于字符编码的假设，C++ 标准库提供了 **区域(local)** 的概念。区域是一组参数，定义了用户的语言和地区首选项，包括国际和文化字符集，以及货币好日期的格式规则

::: tip
关于 **区域** 概念请查看标准库手册，后续也会介绍。目前我们使用默认的区域即可
:::

在标准库 `<cctype>` 中提供许多函数用于分类字符，从这个标准库的名字看，表明它是来自于 C 标准库。因此，只能使用 `#include` 指令包含，而不能使用 `#include` 语句。下表列出来常用的字符分类函数

|函数|描述|
|:---|:---|
|`std::isupper(ch)`|检查字符 `ch` 是否是大写字母|
|`std::islower(ch)`|检查字符 `ch` 是否是小写字母|
|`std::isalpha(ch)`|检查字符 `ch` 是否是字母|
|`std::isdigit(ch)`|检查字符 `ch` 是否是数字字符|
|`std::isxdigit(ch)`|检查字符 `ch` 是否是十六进制数字字符|
|`std::isalnum(ch)`|检查字符 `ch` 是否是数字和字母|
|`std::ispace(ch)`|检查字符 `ch` 是否是空白字符|
|`std::isblank(ch)`|检查字符 `ch` 是否是空格。空格字符包括 `' '` 和 `'\t'`|
|`std::ispunct(ch)`|检查字符 `ch` 是否是标点符号|
|`std::isprint(ch)`|检查字符 `ch` 是否是可打印字符|
|`std::iscntrl(ch)`|检查字符 `ch` 是否是控制字符|
|`std::isgraph(ch)`|检查字符 `ch` 是否是图形字符。除空格之外的所有字符|

::: warning 注意
这些函数的返回值都是 `int` 类型。如果字符的类型与测试的类型相同，返回非 $0$(`true`)，否则返回 $0$(`false`)。原因在于，C 标准库是在 `bool` 类型被引入之前建立的
:::

使用字符分类函数，可以不用硬编码任何对字符集和字符编码的假设

```cpp
#include <iostream>

#include <cctype>


int main()
{
    char letter {};
    std::cout << "Enter a letter: ";
    std::cin >> letter;

    if (std::isupper(letter))
    {
        std::cout << "You entered an uppercase letter." << std::endl;
        return 0;
    }

    if (std::islower(letter))
    {
        std::cout << "You entered a lowercase letter." << std::endl;
        return 0;
    }
    std::cout << "You didn't enter a letter." << std::endl;
    return 0;
}
```

此外，`<cctype>` 还提供了两个字符转换函数，`std::tolower(ch)` 如果字符 `ch` 是大写字母，将其转换为小写字母，否则原样返回；`std::toupper(ch)` 则执行相反操作

## if-else 语句

`if` 语句可以有一个可选的 `else` 子句，当 `if` 语句中的条件为 `fasle` 时，就会执行 `else` 子句中的语句。下图演示了 `if-else` 语句的执行流程

![1762948800212-21c76ce4fe36abf0265b6760442f5a41.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1762948800212-21c76ce4fe36abf0265b6760442f5a41.png)

`if-else` 语句总是会选择执行其中一个语句或者语句块。例如

```cpp
if (std::isalnum(letter))
{
    std::cout << "letter '" << letter << "' is a letter or a digit." << std::endl;
}
else
{
    std::cout << "letter '" << letter << "' is neither a letter nor a digit." << std::endl;
}
```

::: tip
虽然这里的每个语句块中只有一条语句，可以不用使用花括号。但是，使用花括号可以使代码更清晰。同时，采用缩进，以便于清晰显示各个语句之间的关系。

总之，使用花括号 `{}` 包围 `if` 语句的每个分支块是一个好的习惯。
:::

```cpp
#include <iostream>

int main()
{
    long number {};
    std::cout << "Enter an integer less than 2 billion: " << std::endl;
    std::cin >> number;

    if (number % 2)  // 这里利用了非零数值会被编译器转换为 true 的特性
    {
        // 奇数：余数为 1
        std::cout << "Your number is odd." << std::endl;
    }
    else
    {
        // 偶数：余数为 0
        std::cout << "Your number is odd." << std::endl;
    }
}
```

### 嵌套的 if-else 语句

在 `if-else` 语句中，也可以嵌套 `if` 语句或者 `if-else` 语句，这样提供了极大的灵活性。例如

```cpp
if (coffee == 'y')
{
    if (donuts == 'y')
    {
        std::cout << "We have coffee and donuts." << std::endl;
    }
    else
    {
        std::cout << "We have coffee, but not donuts." << std::endl;
    }
}
```

我们在示例代码中使用了花括号。当然，也可以不使用花括号。例如

```cpp
if (coffee == 'y')
    if (donuts == 'y')
        std::cout << "We have coffee and donuts." << std::endl;
    else
        std::cout << "We have coffee, but not donuts." << std::endl;
```

这里，我们使用了缩进来显示每条语句属于那个 `if` 分支。然而，在编写代码时，可能忽略缩进，导致得到错误的结论。例如

```cpp
if (coffee == 'y')
    if (donuts == 'y')
        std::cout << "We have coffee and donuts." << std::endl;
else
    std::cout << "We have coffee, but not donuts." << std::endl;
```

这样的缩进容易让让人误以为 `else` 子句是外层 `if` 的。但是，实际上这里的 `else` 子句属于内层 `if`。总之，**我们在编写 `if-else` 语句时，每个分支的代码块都是使用花括号包围起来即可**

在 C++ 中，如果 `if-else` 语句嵌套在 `if-else` 语句中的 `else` 子句时，C++ 允许进行缩写

```cpp
if (coffee == 'y')
{
    if (donuts == 'y')
    {
        std::cout << "We have coffee and donuts." << std::endl;
    }
    else
    {
        std::cout << "We have coffee, but not donuts." << std::endl;
    }
}
else
{
    if (tea == 'y')
    {
        std::cout << "We have no coffee, bue we have tea." << std::endl;
    }
    else
    {
        std::cout << "No tea or coffee." << std::endl;
    }
}
```

如果继续在 `else` 子句内层嵌套 `if-else` 子句，这将造成缩进灾难，影响可读性。由于 `if-else` 语句只是一条语句，因此，我们对上述底代码结构进行重新排列，得到如下形式的语句

```cpp
if (coffee == 'y')
{
    if (donuts == 'y')
    {
        std::cout << "We have coffee and donuts." << std::endl;
    }
    else
    {
        std::cout << "We have coffee, but not donuts." << std::endl;
    }
}
else if (tea == 'y')
{
    std::cout << "We have no coffee, bue we have tea." << std::endl;
}
else
{
    std::cout << "No tea or coffee." << std::endl;
}
```

这是一种特殊书写形式。由于 `if-else` 语句可以嵌套任意层。因此，**级联式 if-else 语句** 格式如下

```cpp
if(表达式)
    语句
else if (表达式)
    语句
...
else if (表达式)
    语句
else
    语句
```

## 逻辑运算符

在有两个或更多个相关条件的地方使用 `if` 语句较为繁杂。上个例子中，我们把精力放在寻找 `coffee` 和 `donuts` 上，但实际中可能要检查更复杂的条件。例如，搜索年龄在 $20 \sim 35$ 之间的、拥有学士或硕士学历、未婚、说印地语或乌尔都语的女性个人文件。这样将涉及许多个 `if` 测试

逻辑运算符提供了一种简洁的解决方案。使用逻辑运算符，可以把一系列比较组合到一个表达式中，这样，无论条件多么复杂，都只需要一个 `if`。而且，逻辑运算符只有 $3$ 个。下表列出了 C++ 支持的逻辑运算符

|逻辑运算符|描述|
|:---|:---|
|`&&`|逻辑与|
|`\|\|`|逻辑或|
|`!`|逻辑非|

前两逻辑运算符 `&&` 和 `||` 是二元运算符，它们组合了类型为 `bool` 的两个操作数，生成 `bool` 类型的结果。第三个运算符 `!` 是一元运算符，它应用于一个 `bool` 类型的操作数，并生成 `bool` 类型的结果。

### 逻辑与运算符

如果当两个条件必须都是 `true` 时结果才是 `true`，就需要使用逻辑与运算符 `&&`。在之前的示例中，使用嵌套的 `if` 来检测变量 `letter` 是否是大写字母(`letter` 的值必须大于或等于 `'A'` 且小于或等于 `'Z'`)。使用逻辑与运算符表达为

```cpp
if (letter >= 'A' && letter <= 'Z')
{
    std::cout << "This is an uppercase letter." << std::endl;
}
```

只有用运算符 `&&` 组合在一起的两个条件都为 `true` 时，才会执行输出语句。在表达式中，不需要使用圆括号，因为比较运算符的优先级高于 `&&`。当然，也可以加上圆括号强调先执行比较运算符

```cpp
if ((letter >= 'A') && (letter <= 'Z'))
{
    std::cout << "This is an uppercase letter." << std::endl;
}
```

### 逻辑或运算符

如果两个条件中只要有一个为 `true` 或者两个条件都为 `true` 时结果为 `true`，就需要使用逻辑或运算符 `||`。在运算符 `||` 的两个操作数都是 `false` 时，结果才是 `false`

例如，如果收入至少是 $10$ 万元，或者有 $100$ 万元的现金，就肯定可以从银行贷到款。可以使用如下的表达式进行测试

```cpp
if (income >= 100'000.00 || capital >= 1'000'000.00)
{
    std::cout << "Of course, how much do you want to borrow?" << std::endl;
}
```

:::tip
这里使用了数字分隔符来提高数字的可读性
:::

### 逻辑非运算符

逻辑非运算符 `!` 接受一个 `bool` 类型的值，并反转该值。如果布尔类型的变量 `ok` 的值是 `false`，则 `!ok` 的值是 `true`；如果布尔类型的变量 `ok` 的值是 `true`，则 `!ok` 的值是 `false`

所有的逻辑运算符都可以应用于等于 `true` 或者 `false` 的表达式。操作数可以是各种内容，如 `bool` 类型的简单变量，或比较和布尔类型的复杂变量。例如，如果变量 `x = 10`，则表达式 `!(x > 5)` 的值是 `false`，因为 `x > 5` 的判断结果是 `true`

### 组合逻辑运算符

可以把条件表达式和逻辑运算符组合在一起，例如

```cpp
#include <iostream>

int main()
{
    int age {};    // 年龄
    int income{};  // 收入
    int balance{}; // 存款

    std::cout << "Enter your age in years: ";
    std::cin >> age;
    std::cout << "Enter your annual income in dollars: ";
    std::cin >> income;
    std::cout << "What is your current account balance in dollars: ";
    std::cin >> balance;

    // 1. 必须满足大于或等于 21 岁
    // 2. 年收入大于或等于 25'000 或者 存款在大于或等于 100’000
    // 才能进行贷款

    if (age >= 21 && (income >= 25'000 || balance >= 100'000))
    {
        // 满足贷款条件
        // 贷款额为 年薪的两倍、存储的一半中的最小值
        int loan {};
        // 年薪的两倍小于存款的一半
        if(2 * income < balance / 2)
        {
            loan = 2 * income;
        }
        else
        {
            loan = balance / 2;
        }
        std::cout << "You can borrow up to $" << loan << std::endl;
    }
    else
    {
        std::cout << "Unfortunately, you don't qualify for a loan." << std::endl;
    }
}
```

这个程序的输出如下

```shell
Enter your age in years:21
Enter your annual income in dollars:28000
What is your current account balance in dollars:185000
You can borrow up to $56000
```

### 对整数应用逻辑运算符

逻辑运算符可以并且实际上经常被用于整数操作数，而非布尔操作数。例如，在前面看见的，可以使用下面的底阿妈测试整数变量 `value` 是否为 $0$

```cpp
if (value)
{
    std::cout << "You have entered a value that is different from zero." << std::endl;
}
```

同样，也可以使用如下测试

```cpp
if (!value)
{
    std::cout << "You have entered a value that equals zero." << std::endl;
}
```

类似的，还可以检查两个变量是否均不为 $0$

```cpp
if (value1 && value2)
{
    std::cout << "Both values are non-zero." << std::endl;
}
```

::: tip

在表达式中，逻辑运算符的每个操作数必须是 `bool` 类型，这里的操作数确实数值类型，因此编译器会对逻辑运算符的每个操作数进行类型转换，将其转换为 `bool` 类型

换言之，$0$ 转换为 `false`；$1$ 转换为 `true`。既是逻辑运算符的操作数全是数值类型，最终逻辑表达式的类型也是 `bool` 类型

:::

### 对比逻辑运算符和位运算符

逻辑运算符 `&&` `||` 和 `!` 与位运算符 `&` `|` 和 `~` 要严格区分。这非常重要：**逻辑运算符用于可转换为 `bool` 类型的操作数**，**位运算符用于整数操作数中的位**

逻辑运算符的结果总是一个 `bool` 类型的值，既是操作数全是数值类型。对于位运算符，正好相反：它们的结果总是一个整数，既是两个操作数都是 `bool` 类型

::: tip

由于按位运算符的结果可以转换回 `bool` 类型，所以看起来逻辑运算符和位运算符似乎是可以互换使用的

实际开发中，不要利用这个特性。该用逻辑运算符的地方一定不要使用位运算符

:::

真正需要理解并掌握的是逻辑运算符与位运算符之间的一个本质差别：**二元逻辑运算符是短路运算符**

::: tip

对于使用二元逻辑运算符组合的表达式，会按照从左到右依次计算表达式的值，一旦能够确认整个表达式的值时，就会停止计算。

:::

考虑下面的代码

```cpp
int x = 2;

if (x < 0 && (x * x + 632 * x == 1268))
{
    ...
}
```

表达式 `x < 0 && (x * x + 632 * x == 1268)` 的值是根据 `x < 0` 确定的，因为 `x < 0` 的值是 `false`，在逻辑与运算中，只要出现 `false`，整个表达式的值就是 `false`。

在考虑如下代码

```cpp
int x = 2;

if (x == 2 || (x * x + 632 * x == 1268))
{
    ...
}
```

表达式 `x == 2 || (x * x + 632 * x == 1268)` 的值是根据 `x == 2` 确定的，因为 `x == 2` 的值是 `true`，在逻辑或运算中，只要出现 `true`，整个表达式的值就是 `true`

在上述两个示例代码中，第二个表达式根本不会进行计算，从而节省一些时间。逻辑运算符 `&&` 和 `||` 的这种属性称为短路计算。然而，按位运算符 `&` 和 `|` 则不会短路

::: tip

我们只需要记住，对于 `&&` 运算符，左边操作数出现 `false`，右边的操作数就不在计算。对于 `||` 运算符，左边操作数出现 `true`，右边操作数就不会计算

:::

## 条件运算符

条件运算符有时也称为三元运算符，因为它涉及三个操作数，这也是唯一的一个三元运算符。它本质上是简单的 `if-else` 语句的简化。

例如，假定有两个变量 `a` 和 `b`，要把这两个变量中较大的值赋值给第三个变量 `c`。使用 `if` 语句完成如下

```cpp
if (a > b)
{
    c = a;
}
else
{
    c = b;
}
```

这种满足条件就进行赋值的操作可以使用条件运算符完成。因此，上述语句简化为

```cpp
c = a > b ? a : b;
```

如果表达式 `a > b` 的值是 `true`，就将 `a` 的值赋值给 `c`；否则，将 `b` 的值赋值给 `c`。

回到我们的贷款程序中，使用 `if-else` 语句确定贷款额度就可以使用如下语句替换

```cpp
loan = 2 * income < balance / 2 ? 2 * income : balance / 2;
```

这里完全不需要使用圆括号。因为，`?:` 运算符的优先级足够低，它低于大部分运算符。当然，也开始显式使用圆括号使得代码更清晰

```cpp
loan = (2 * income < balance / 2) ? (2 * income) : (balance / 2);
```

## switch 语句

我们常常面临 **多项选择** 的情形，这种情况下，需要根据某个表达式的值从待选择的项中找出需要的执行的项。C++ 中可以使用两种方式：一是嵌套的 `if-else` 语句，二是 `switch` 语句。下面我们来看例子：如果一位顾客购买了一张号码的彩票，如果运气好，就会赢得大奖。例如，如果彩票号码是 $147$，就会赢得头等奖。如果彩票号码是 $387$，就会赢得二等奖。如果彩票号码是 $29$，就会赢得三等奖。其他号码则不能获奖。通过这个例子的描述，我们可以使用嵌套的 `if-else` 语句完成

```cpp
// ...
if (ticket_number == 147)
{
    // 获得头等奖
}
else if (ticket_number == 387)
{
    // 获得二等奖
}
else if (ticket_number == 29)
{
    // 获得三等奖
}
else
{
    // 不获奖
}
```

使用 `if-else` 语句完成有一个缺点，就是要从上到下依次进行比较，直到遇见符合条件的分支或者执行 `else` 分支。我们可以通过使用 `switch` 语句来避免这种依次比较的问题。

```cpp
switch (ticket_number)
{
    case 147:  // 当 ticket_number == 147 时，执行该 case 标签中的语句
        // 获得头等奖
        break;
    case 387:
        // 获得二等奖
        break;
    case 29:
        // 获得三等奖
        break;

    default:  // 当 ticket_number 没有选择上面的任何 case 值，则执行 default 标签中的语句
        // 未获奖
        break;
}
```

`switch` 语句难以描述，但是使用起来比较简单。在许多的 `case` 中进行选择，取决于关键字 `switch` 后面圆括号中 **整数表达式** 的值。

::: warning

C/C++ 中的 `switch` 语句中，**`switch` 后面圆括号中的表达式的值的类型必须是整型**，包括整型值(`int`、`unsigned int`、`char`、枚举值)。并且，**跟随在 `case` 关键字后面表达式必须是整数类型的常量表达式**

从技术角度看，也允许对布尔值使用 `switch`，但是这种情况下，其实应该使用 `if-else` 语句。
:::

将 `switch` 语句中可能的选项放在一个语句块中，每个选项都用一个 `case` 值标识。`case` 值显式在 `case` 标签中，其形式如下

```cpp
case case_value:
```

`case` 标签标注了后面的语句或语句块。如果选择表达式的值等于 `case` 值，就执行该 `case` 标签后面的语句。**每个 `case` 值都必须是唯一的**，但没有必要按顺序。

**`case` 值必须是整数常量表达式**，即编译器可以在编译时求值的表达式。通常，使用整数字面值常量，也可以使用 `constexpr` 声明的编译时常量。显然，任何 `case` 值都必须与其所在 `switch` 语句的条件表达式具有相同的类型，或者可以转换为该类型的值

`default` 标签标识默认的 `case`。如果选择表达式不对应于任何一个 `case` 值，就执行该默认 `case` 后的语句。对于 `default` 标签，并不需要把它作为最后一个标签。但是，常常把它放在最后。当然，`default` 标签并不是必须得，如果没有指定 `default` 标签，且没有选中任何 `case` 值，则 `switch` 语句什么也不做

从逻辑上看，每一个 `case` 语句后面的 `break` 语句绝对是必需的，它在 `case` 语句执行后跳出 `switch` 语句，使得程序就像执行 `switch` 右花括号后的语句。如果省略 `case` 后面的 `break` 语句，就将执行该 `case` 标签后面的其他 `case` 标签，直到遇见 `break`。

::: tip

通常，最后一个 `case` 标签不需要 `break` 语句，因为此时程序将退出 `switch` 语句。但是，一个好习惯就是每个 `case` 标签的最后一条语句必须加上 `break` 语句

:::

下面的示例程序演示了 `switch` 语句的用法

```cpp title="switch.cpp"
#include <iostream>

int main()
{
    std::cout << "You electronic recipe book is at your service.\n"
            << "You can choose from teh following delicios dishes:\n"
            << "1. Boiled eggs\n"
            << "2. Fried eggs\n"
            << "3. Scrambled eggs\n"
            << "4. Coddled eggs\n"
            << "Enter your selection numbers: ";

    int choice {};
    std::cin >> choice;

    switch (choice)
    {
        case 1:
            std::cout << "Boil some eggs\n";
            break;
        case 2:
            std::cout << "Fry some eggs\n";
            break;
        case 3:
            std::cout << "Scramble some eggs\n";
            break;
        case 4:
            std::cout << "Coddle some eggs\n";
            break;
        default:
            std::cout << "You entered a wrong number - try row eggs.\n";
    }
    return 0;
}
```

上述程序的输出如下

```shell
You electronic recipe book is at your service.
You can choose from teh following delicios dishes:
1. Boiled eggs
2. Fried eggs
3. Scrambled eggs
4. Coddled eggs
Enter your selection numbers: 1
Boil some eggs
```

前面说过，每个 `case` 值都必须是编译时常量，并且必须是唯一值。任何两个 `case` 值都不能相同的原因是，如果输入某个指定值，编译器就无法确定应执行哪些语句。但是，**`case` 值不同，并不表示必须执行不同的操作。几个 `case` 标签可以共享相同的操作**

```cpp title="letter.cpp"
#include <iostream>
#include <cctype>

int main()
{
    char letter {};
    std::cout << "Enter a letter: ";
    std::cin >> letter;

    // 检查输入字符是否是字母
    if(std::isalpha(letter))
    {
        // 将字母转换为小写
        switch (std::tolower(letter))
        {
            case 'a':
            case 'e':
            case 'i':
            case 'o':
            case 'u':
                std::cout << "You entered a vowel.\n";
                break;

            default:
                std::cout << "You did not enter a letter.";
        }
    }
    else
    {
        std::cout << "You did not enter a letter.\n";
    }
}
```

这个程序的输出如下所示

```shell
Enter a letter: E
You entered a vowel.
```

`break` 语句并不是使控制权移出 `switch` 语句的唯一方式。如果 `case` 标签中的代码包含 `return` 语句，则控制权不仅离开 `switch` 语句，还将离开包含 `switch` 语句的函数。因此，原则上可以把上例中的代码改成如下

```cpp title="letter.cpp"
#include <iostream>
#include <cctype>

int main()
{
    char letter {};
    std::cout << "Enter a letter: ";
    std::cin >> letter;

    // 检查输入字符是否是字母
    if(std::isalpha(letter))
    {
        // 将字母转换为小写
        switch (std::tolower(letter))
        {
            case 'a':
            case 'e':
            case 'i':
            case 'o':
            case 'u':
                std::cout << "You entered a vowel.\n";
                return 0;  // [!code highlight]

            default:
                std::cout << "You did not enter a letter.";
        }
    }
    else
    {
        std::cout << "You did not enter a letter.\n";
    }
}
```

### 贯穿

每组 `case` 语句最后的 `break` 语句使得 `switch` 之后的语句开始执行。通过在前面的示例中，从 `switch` 语句移除 `break`，查看会发生什么情况，可以演示 `break` 语句的本质。**移除了某个 `case` 标签中的 `break` 语句后，它下面的 `case` 标签的代码也会执行**，这种现象被称为 **贯穿(fallthrough)**，因为在某种意义上，我们贯穿到下一个 `case`。

很多时候，缺失 `break` 语句是疏忽大意的缘故，说明存在 `bug`。为了演示这一点，我们回到彩票示例代码中

```cpp title="ticket.cpp"
#include <iostream>

int main()
{
    int ticket_number {};
    std::cout << "Welcome to our Challenge Tickets!\n";
    std::cin >> ticket_number;

    switch (ticket_number)
    {
        case 147:
            std::cout << "You win first prize!\n";
            // 注意这里没有break // [!code highlight]
        case 387:
            std::cout << "You win second prize!\n";
            break;
        case 29:
            std::cout << "You win third prize!\n";
            break;
        default:
            std::cout << "Sorry, you lose.\n";
            break;
    }
}
```

注意，这一次第一个 `case` 的 `break` 语句被丢掉了。如下现在执行 `switch` 语句，使 `ticket_number` 等于 $147$，则输出如下

```shell
You win first prize!
You win second prize!
```

因为 `ticket_number` 等于 $147$，`switch` 语句会跳转到对应的 `case`，说明顾客赢得了头等奖。但是，因为没有 `break` 语句，下一个 `case` 标签的语句也会执行，消息指出顾客也获得了二等奖。显然，这是忽略 `break` 语句导致的结果。**大多数情况下，贯穿代表存在 `bug`，所以如果非空的 `switch case` 没有跟上一个 `break` 语句或 `return` 语句，许多编译器会发出警告**。

但是，贯穿并不意味着错误。有时，故意写一个利用贯穿行为的 `switch` 语句会很有用。假设在彩票号码示例中，有许多号码能够赢得二等奖和三等奖，而赢得三等奖的某个号码会获得额外奖励。例如

```cpp title="ticket.cpp"
#include <iostream>

int main()
{
    int ticket_number {};
    std::cout << "Welcome to our Challenge Tickets!\n";
    std::cin >> ticket_number;

    switch (ticket_number)
    {
        case 147:
            std::cout << "You win first prize!\n";
            break;
        case 387:
        case 123:
            std::cout << "You win second prize!\n";
            break;
        case 929:
            std::cout << "You win a special bonus prize!\n";
        case 29:
        case 78:
            std::cout << "You win third prize!\n";
            break;
        default:
            std::cout << "Sorry, you lose.\n";
            break;
    }
}
```

这里的思想是，如果 `ticket_number` 等于 $929$，则结果应该如下所示

```shell
You win a special bonus prize!
You win third prize!
```

对于这种代码，令人烦恼的地方是，尽管在这里贯穿并不是错误，但是编译器还是可能会发出贯穿警告。正在 C++17 之前，我们应该重构代码，加上赢得三等奖的输出语句。但是，一般般避免重复代码。在 C++17 中添加了一个新的语言功能，可告诉编译器和阅读代码的人，我们在某个地方故意使用了贯穿行为：在原本需要 `break` 语句的地方，添加 `[[fallthrough]]`

```cpp{20} title="ticket_fallthrough.cpp"
#include <iostream>

int main()
{
    int ticket_number {};
    std::cout << "Welcome to our Challenge Tickets!\n";
    std::cin >> ticket_number;

    switch (ticket_number)
    {
        case 147:
            std::cout << "You win first prize!\n";
            break;
        case 387:
        case 123:
            std::cout << "You win second prize!\n";
            break;
        case 929:
            std::cout << "You win a special bonus prize!\n";
            [[fallthrough]];  // [!code focus]
        case 29:
        case 78:
            std::cout << "You win third prize!\n";
            break;
        default:
            std::cout << "Sorry, you lose.\n";
            break;
    }
}
```

## 语句块和变量作用域

`switch` 语句一般在花括号中包含自己的语句块，其中包括 `case` 语句。`if` 语句也常在花括号中包含条件为 `true` 时执行的语句，其中 `else` 部分也可以包含花括号。注意，这些语句块与定义变量作用域时涉及的其他语句块没有任何区别。在语句块中声明的任何变量都会在语句块结束时会自动消失，所以不能再语句块外引用它们

例如，考虑下面代码

```cpp
if (value > 0)
{
    int savit {value - 1};  // 仅在该语句块中能够被访问
    value += 10;
}
else
{
    int savit {value + 1};  // 仅在该语句块中能够被访问
    value -= 10;
}
std::cout << savit;  // error: 名字 savit 不存在
```

::: danger

上述代码编译只会最后得到一条编译错误的信息，因为此时变量 `savit` 未定义。在语句块中定义的变量只能在该语句块中使用。如果在语句块外部访问语句块内部的数据，就必须把存储该信息的变量定义在语句块外部

:::

在 `switch` 语句块中的变量定义必须能在执行该语句块是访问，不能通过跳转到相同作用域内位于变量声明之后的 `case` 语句来绕过定义，否则代码编译就会报错。来看如下示例代码

```cpp
int test {};

switch (test)
{
    int i {1};  // 不合法：语句块正常执行过程中无法访问
    case 1:
        int j {2};  // 不合法：直接跳转到 case 3 或者 default 标签执行，跳过了改变了的实际定义位置
        std::cout <<  test + j << std::endl;
        break;
        int k {3};  // 不合法的定义：语句块正常执行过程中无法访问

    case 3:
    {
        int m {4}:  // 合法的变量定义
        std::cout << test + m << std::endl;
        break;
    }

    default:
        int n {5};  // 合法的变量定义、如果 default 之后还有其他 case 标签，那么变量 n 的声明也是非法的
        std::cout << test + n << std::endl;
        break;
}
std::cout << j << std::endl;  // 变量 j 不存在
std::cout << n << std::endl; // 变量 n 不存在
```

在上述示例代码中，变量 `m` 和 `n` 是合法的，因为它们可以 **在该语句块的正常执行过程访问**；然而，变量 `i` 和 `k` 的定义就不可以。其次，**不能绕过变量的定义进入该变量的作用域**，如果执行跳转到 `case 3` 标签或者 `default` 标签，就跳过了变量 `j` 的实际定义，而进入改变了的作用域。所以，变量 `i` `j` 和 `k` 都是非法的。

::: tip

一个好的编程实践就是：不要在 `switch-case` 语句中声明变量，如果必须声明，则最好在 `case` 标签中添加花括号，并在花括号中声明变量

:::

### 初始化语句

在 C++ 中，`if` 和 `switch` 语句可以带有一个初始化语句。考虑如下代码段

```cpp
auto lower {static_cast<char>(std::tolower(input))};
if (lower >= 'a' && lower <= 'z' )
{
    std::cout << "You've entered the letter '" << lower << "'\n";
}
// ....
```

这里我们将 `input` 字符转换为小写字符 `lower`，然后使用转换结果来检查输入是不是一个字符，如果是，就生成一些输出。然而，`lower` 变量只在 `if` 语句中使用，之后的任何代码不在使用该变量。一种良好的编程风格就是将 `lower` 变量的作用域限制在它使用的区域内。例如

```cpp
{
    auto lower {static_cast<char>(std::tolower(input))};
    if (lower >= 'a' && lower <= 'z')
    {
        std::cout << "You've entered the letter '" << lower << "'\n";
    }
}
// ....
```

引入一个额外的作用域将局部变量绑定到 `if` 语句，这是非常常见的。所以，C++17 专门引入了一种新语法，其一般形式如下

```cpp
if (initialization; condition) ...
```

在计算 `condition` 表达式之前，会先执行 `initialization`。这种初始化语句主要用于声明 `if` 语句的局部变量。因此，前面的代码段可以重写为如下形式

```cpp
if (auto lower {static_cast<char>(std::tolower(input))}; lower >= 'a' && lower <= 'z')
{
    std::cout << "You've entered the letter '" << lower << "'\n";
}
// ....
```

为了完整起见，C++ 还为 `switch` 语句添加了一种类似的语法

```cpp
switch (initialization; condition)
{
    ....
}
```
