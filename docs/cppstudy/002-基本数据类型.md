---
title: 基本数据类型
createTime: 2025/11/13 22:09:25
permalink: /cppstudy/ess2neey/
tags:
  - C/C++
---

## 变量-数据和数据类型

**变量是用户定义的一个命名的内存段**。每个变量都只存储特定类型的数据，也就是说，每个变量都有一个类型，定义了可以存储的数据类别。每个基本类型都使用唯一的类型名称来标识。请注意，类型名称可能是由一个或多个 **关键字** 组成

::: tip
**关键字**：由 ISO C++ 标准定义的由编译器使用的名字。显然，这些名字不能被用于其他目的
:::

编译器会进行大量的检查，确保在给定的上下文中使用正确的数据类型，它还确保在操作中合并不同的类型时，它们要么有相同的类型，要么可以把一个值转换另一个类型的值，使它们相互兼容(隐式类型转换)。编译器会报告试图将不兼容的数据类型组合在一起而产生的错误

在 C++ 中，数值类型分为两类，分别是 **整数** 和 **浮点数**（小数）。C++ 为整数和浮点数提供了可以存储不同数值范围的类型。

### 定义整型变量

下面的语句定义了一个整型变量

```cpp
int apple_count;
```

这个语句定义了一个 `int` 类型的变量 `apple_count`，该变量包含了某个随机的垃圾值。在定义该变量时，可以而且应该指定初始值，如下所示

```cpp
int apple_count {15};  // Number of apples
```

`apple_count` 的初始值放在变量名后的花括号中，所以其值为 $15$。**包含初始值的花括号称为初始化列表**。虽然，在定义变量时不用初始化它们，但是最好进行初始化。确保变量一开始就有已知的值，在代码不像预期那样工作时，将便于定位错误的位置

类型 `int` 的大小一般为 $4$ 字节，可以存储 $-2^{31} \sim 2^{31} -1$，即 $-2147483648 \sim 2147483647$。这覆盖了大多数情形，所以 `int` 是最常用的整数类型

下面是三个 `int` 类型变量的定义：

```cpp
int apple_count {15};
int orange_count {5};
int total_fruit {apple_count + orange_count};
```

`total_fruit` 的初始值是变量 `apple_count` 和 `orange_count` 的和。这说明，**变量的初始值可以是表达式**。在源文件中，变量 `apple_count` 和 `orange_count` 的定义要在变量 `total_fruit` 之前。

C++ 还支持另外两种变量初始化方式，分别是 **函数式初始化** 和 **C 风格初始化**，如下所示

```cpp
int lemon_count (4);  // 函数式初始化

int tomato_count = 12;  // C 风格初始化
```

在大部分情形下，这三种方式是等效的。但是，当发生 **窄化类型转换**(narrowing conversion) 时，初始化列表形式(花括号形式)会更加安全，因为花括号形式禁止这种转换的发生

```cpp
int banana_count {7.5}; // 错误：发生窄化类型转换，编译器禁止这种转换

int tangerine_count = 5.3; // OK: 截断为整数
```

::: tip
窄化类型转换：将表示范围更大类型的值转换为表示范围更小类型的值。这种转换可能会导致信息丢失；即当目标类型无法保存原始值时，就会丢失部分信息
:::

通常，变量在初始化时提供的初始化表达式的类型与变量的类型相同。如果不同，编译器会尝试进行类型转换。就 C++ 标准而言，变量 `tangerine_count` 的定义完全合法。能够通过编译，某些编译器会发出警告，某些则不会。然而，对于 `{}` 形式的初始化器，C++ 标准要求禁止窄化类型转换。例如，

```cpp
int papaya_count {0.3};  // error：发生窄化类型转换，编译器禁止这种转换。至少应该抛出警告
```

花括号（`{}`）形式的初始化器是 C++11 标准引入的。除了禁止窄化类型转换外，还能以相同的方式初始化所有变量，因此也称为 **统一初始化器**。在定义变量时，**可以在一条语句中定义和初始化多个变量**。例如

```cpp
int foot_count {2}, toe_count {10}, head_cout{1};
```

::: warning
最好是在单个语句中定义每个变量。这会提高代码的可读性，还可以注释每个变量的作用
:::

基本类型的变量可以非常方便的将变量值写入到标准输出。下面的程序演示这一点

```cpp title="variable.cpp"
// variable.cpp
// 将基本类型变量的值写入标准输出流中
#include <iostream>

int main()
{
    int apple_count {15};
    int orange_count {5};
    int total_fruit {apple_count + orange_count};

    std::cout << "The value of apple_count is " << apple_count << std::endl;
    std::cout << "The value of orange_count is " << orange_count << std::endl;
    std::cout << "The value of total_fruit is " << total_fruit << std::endl;
}
```

### 整型限定符

在 [第 1 章 基本概念#存储整数](./001-基本概念.md#存储整数) 中介绍过计算机中采用不同长度的位模式来编码整数，其中整数分为有符号整数和无符号整数。为了适应这种变化，C++ 标准提供了 **整型限定符** 用于修改整型 `int` 的行为。目前 C++ 标准支持下表列出的几个整型限定符

|限定符|描述|示例|
|:---|:---|:---|
|`signed`|有符号整数限定符，表示有符号整数|`signed int`|
|`unsigned`|无符号整数限定符，表示无符号整数|`unsigned int`|
||||
|`short`|整型长度限定符，比 `int` 尺寸更小 |`short int`|
|`long`|整型长度限定符，比 `int` 尺寸更大 |`long int` 或者 `long long int`|

将整型 `int` 与其限定符进行组合，可以得到下表列出的 8 中整数类型

| 整数类型                                   | 描述           |
| :------------------------------------- | :----------- |
| `short int` 或者 `signed short int`         | 有符号短整数       |
| `unsigned short int`                   | 无符号短整数       |
| `int` 或者 `signed int`                     | 有符号整数        |
| `unsigned int`                         | 无符号整数        |
| `long int` 或者 `signed long int`           | 有符号长整数       |
| `unsigned long int`                    | 无符号长整数       |
| `long long int` 或者 `signed long long int` | 有符号长长整数 |
| `unsigned long long int`               | 无符号长长整数|

::: tip
默认情形下，类型 `int` 是 `signed` 的。 也就是说 `signed` 是可以省略的

此外，这些限定符只用于整型 `int`。换句话说， 在有限定符的情形下， `int` 也是可以省略的
:::

### 整型的尺寸

各种整数类型所占用的内存和值域由编译器决定的，C++ 标准并未规定这些整数类型应该占用多少字节。但是，规定了整数类型的尺寸应该满足下面的关系

::: tip

+ `sizeof(short int) <= sizeof(int) <= sizeof(long int) <= sizeof(long long int)`

+ `sizeof(signed Type) == sizeof(unsigned Type)`

`sizeof` 是 C++ 中的一个运算符，用户获取对象或类型的尺寸(字节为单位)
:::

下表列出来在 32 位机器和 64 位机器上的典型尺寸

| 类型                     | 32位平台尺寸    | 64 位平台尺寸  |
| :----------------------- | :------------- | :------------- |
| `short int`              | 2 字节         | 2 字节          |
| `unsigned short int`     | 2 字节         | 2 字节          |
| `int`                    | 2 字节         | 4 字节          |
| `unsigned int`           | 2 字节         | 4 字节          |
| `long int`               | 4 字节         | 8 字节          |
| `unsigned long int`      | 4 字节         | 8 字节          |
| `long long int`          | 8 字节         | 8 字节          |
| `unsigned long long int` | 8 字节         | 8 字节          |

### 零值初始化

下面的语句定义了一个初始化值为 0 的整型变量

```cpp
int counter {0};
```

在这里的初始化列表中，可以省略 0，效果是相同的。因此，定义变量 `counter` 的语句也可以写成如下形式

```cpp
int counter{};
```

空花括号有些类似于数字 0，使得这种语法很容易被记住。对于任何基本的类型，都可以使用零值初始化

### 只读变量

有时候希望定义有 **固定值** 或者 **值不变** 的变量。在变量的定义中使用 `const` 关键字，就可以定义不能修改的变量。这种变量常被称为常量。例如：

```cpp
const int toe_count {10};  // 只读变量
```

`const` 关键字告诉编译器，`toe_count` 的值不能修改。尝试修改 `toe_count` 值的语句都会在编译时标记为错误。

## 整数字面值

在 C++ 中，任何类型都有 **字面值**，例如 `42`、`2.71828`、`'Z'` 或者 `"Mark Twain"`。

::: tip
字面值是字节写在程序源代码中，而无需使用变量的值。例如，语句 `const int toe_count {10};` 中的 `10` 就是字面值
:::

请注意：字面值是有类型的。这里我们首先介绍整型字面值。C++ 支持 4 中整型字面值，分别是 **十进制字面值**、**十六进制字面值**、**八进制字面值** 和 **二进制字面值**

::: info
下面给出了这四种整数字面值形式的词法定义

```shell
integer:      decinteger | bininteger | octinteger | hexinteger | zerointeger [ "U" | "L" | "UL" | "LL" | "ULL" ]
decinteger:   nonzerodigit (["'"] digit)*
bininteger:   "0"("b" | "B") (["'"] bindigit)+
octinteger:   "0"(["'"] octdigit)+
hexinteger:   "0"("x" | "X") (["'"] hexdigit)+
zerointeger:  "0"(["'"] "0")*
nonzerodigit: "1"..."9"
digit:        "0"..."9"
bindigit:     "0" | "1"
octdigit:     "0"..."7"
hexdigit:     digit | "a"..."f" | "A"..."F"
```

在这个定义中，`|` 表示或者；`[...]` 表示其中的内容是可选的; `+` 表示前面的符号至少出现一次; `*` 表示前面的符号至少出现零次

注意：八进制整数字面值使用 `0` 作为前缀。
:::

### 十进制字面值

十进制字面值是最常用的整数字面值。下面是十进制字面值整数的一些例子

```cpp
-123L   +123    123     22333   98U     -1234LL     12345ULL
```

整数字面值的默认类型是 `int`。如果需要表示其他类型的整数字面值，可以添加后缀

+ 后缀 `U` 表示整数字面值类型是 `unsigned int`
+ 后缀 `L` 表示整数字面值类型是 `long`
+ 后缀 `UL` 表示整数字面值类型是 `unsigned long`
+ 后缀 `LL` 表示整数字面值的类型是 `long long`
+ 后缀 `ULL` 表示整数字面值的类型是 `unsigned long long`。

::: tip
请注意，这些后缀的小写形式也满足要求，但是为程序可读性，不建议使用小写。因为小写字母 `l` 与数字 `1` 容易混淆
:::

字面值 `+123` 中的 `+` 可以省略，因为这是默认的。因此，字面值 `+123` 和 `123` 是相同的，都是 `int` 类型。从 C++14 标准起，可以在整数字面值中使用单引号(`'`)将整数字面值进行分组使数字更便于阅读。如何分组数字并没有标准，不同的地区使用可能使用不同的方式。例如

```cpp
22'333      -1'234L     12'345ULL
```

请注意：初始值必须位于变量类型允许的范围内，且类型必须匹配。否则，可能发生窄化类型转换，导致初始值并非我们需要的内容。例如

```cpp
unsigned char high_score {513U};  // error：窄化类型转换
unsigned char high_score {-1};  // -1 的类型是 signed int
```

### 十六进制字面值

整数字面值可以使用十六进制表示。十六进制整数字面值需要使用 `0x` 或者 `0X` 开头。所以 `0x999` 是一个 `int` 类型的十六进制数，它有 $3$ 个十六进制数字，而普通的数字 `999` 是一个 `int` 类型的十进制数，它有 $3$ 个十进制数字，它们是完全不同的。

**十六进制整数字面值主要用于定义特定的位模式**。因为每个十六进制位都对应二进制值的 $4$ 位，所以很容易把位模式表示为特定的十六进制数字。像素颜色的红、蓝、绿成分值(RGB值)常常表示为 32 位字的 3 个字节。白色可以指定为 `0xFFFFFF`，因为在白色中，上述三种颜色成分的强度都是最大值 `255(0xFF)`。红色则是 `0xFF0000`

### 八进制字面值

整数字面值也可以表示成八进制形式，即以 8 为基数。把数值表示为八进制是，要添加一个前导 0。例如

```cpp
0567    0443U   012L    0625    0377
```

### 二进制字面值(C++14)

二进制整数字面值是在 **C++14** 标准中引入的，二进制整数字面值使用 `0b` 或者 `0B` 作为前缀。例如

```cpp
0b110101111     0B100100011U    0b1010L     0b11111111
```

::: warning 注意
编译器并不在意使用何种形式的字面值，因为这些字面值在内存中都是按照位模式存储的。在表示整数时，那个方便就是使用那个
:::

## 整数的计算

运算由运算符定义，例如，运算符 `+` 执行加法运算，运算符 `*` 执行乘法运算。运算符操作的对象称为操作数。在表达式 `2 * 3` 中，操作数就是 2 和 3.乘法运算需要两个操作数，所以称为 **二元运算符**。只需要一个操作数的运算符称为 **一元运算符**。表达式 `-width` 中，`-` 就是一元负号，表示对 操作数 `width` 的符号取反。换句话说，如果 `width < 0`，那么 `-width > 0`

下表列出了对整数可以进行的基本 **算术运算**

|运算符|运算|
|:---|:---|
|`a + b`|加法|
|`a - b`|减法|
|`a * b`|乘法|
|`a / b`|除法|
|`a % b`|取模(计算 `a / b` 的余数)|

这是算术运算符都是二元运算符，其工作方式与我们期望的大致相同。不同，对于运算符 `/` 和 `%` 需要做特殊说明

在 C++ 中，整数除法相对特殊。**当运算符 `/` 用于两个整数操作数时，其运算结果总是整数**。例如，假设进行下面的运算：

```cpp
int numerator = 11;
int quotient = numerator / 4;
```

从数学上来说，除非运算 `11 / 4` 的结果应该是 `2.75`。但是，`2.75` 不是整数，计算机会自动舍弃小数部分 `0.75` 得到的结果是 `2`。

::: tip
整数除法 `a / b` 是返回的结果是 `a` 是 `b` 的几倍，任何多余的部分都将舍弃
:::

取模运算符 `%` 是对整数除法的补充，它提供了一种在整数除法运算后获取其余数的方式。取模运算的是根据公式 $remainder = dividend - \lfloor dividend \div divisor \rfloor$ 进行计算的。使用这个公式，很容易推断出负操作数使用取模运算的结果

::: tip
**表达式 `a % b` 结果的符号始终与 `a` 的符号相同**。例如，`a = -10` 和 `b = 7`，`-10 % 7 = -10 - (-10 / 7) = -10 - (-1) = -9 `

**当右操作数为 $0$ 时，除法和取模的结果都是未定义的**。换句话说，运算结果取决于编译器
:::

### 复合算术运算

如果同一个表达式中使用了多个运算符，那么乘法、除法、和取模运算在加减操作之前执行。例如

```cpp
long width {4};
long length {5};
long area {width * length};
long perimeter {2 * width + 2 * length}; // 18
```

使用圆括号可以控制较复杂表达式的执行顺序。例如，计算 `perimeter` 值的语句可以写作

```cpp
long perimeter {2 * (width + length)};  // 18
```

圆括号中的子表达式先计算，再将结果乘以 2，最终得到与前述语句相同的值。但是，如果这里不使用圆括号，结果就会计算错误

```cpp
int perimeter {2 * width + length};  // 结果是 13
```

这是因为，乘法先于加法计算。因此，上述语句等价于

```cpp
int perimeter {(2 * width) + length};
```

圆括号可以嵌套，即圆括号中的子表达式按照从最内层的圆括号到最外层的圆括号的顺序计算。例如

```cpp
2 * (a + 3 * (b + 4 * (c + 5 * d)))
```

表达式 `5 * d` 先计算，结果再加上 `c`，之后再乘以 `4`，接着加上 `b`，然后将结果乘以 `3`，再加上 `a`。最后把结果乘以 `2`，得到整个表达式的值

::: warning
无论默认计算顺序如何，都可以使用圆括号改变计算顺序。并且可以使得表达式计算顺序更清晰
:::

## 赋值运算

在 C++ 中，只有使用了 `const` 限定符后，变量的值才是只读的。在其他情形下，总是可以使用新值覆盖变量原来的值

```cpp
long perimeter {};
// ...
perimeter = 2 * (width + length);
```

运算符 `=` 是赋值运算符。计算赋值运算符的右边表达式的值，结果存储在赋值运算符左侧的变量中。严格来说，并不是必须在声明 `perimeter` 变量的时候就初始化该变量，只要在对该变量赋值之前没有读取它即可。

::: info
变量声明即初始化是一种好做法。0 常常时一个很好的初始值
:::

在 C++ 中，赋值运算符可以 **以串联的方式同时为多个变量赋值**，例如

```cpp
int a{}, b{}, c{5}, d{4};

a = b = c * c - d * d;
```

首先，计算表达式 `c * c - d * d` 的值，并将该值赋值给变量 `b`，然后将表达式 `b = c * c - d * d` 的值赋值给变量 `a`。所以，`b` 的值是 `9`；`a` 的值也是 `9`

::: warning
不要将赋值运算符 `=` 与代数上的 `=` 混淆。代数上的运算符 `=` 表示相等性比较
:::

赋值运算符 `=` 就是重写指定内存位置的操作。变量可以被重写任意次，每次都可以有不同的值。例如

```cpp
int x{5};

x = x + 1;
```

首先，变量 `x` 被初始化为 5，所以表达式 `x + 1` 的值是 6。这个结果被重写到 `x` 命名的内存中。

下面是一个示例程序：该程序执行一个距离换算操作

```cpp title="convert_distances.cpp"
// convert_distances.cpp
// 执行距离转换操作。码 英尺 英寸
#include <iostream>

int main() {
    //            码       英尺     英寸
    unsigned int yards{}, feet{}, inches{};   // 声明 3 个无符号整数变量。因为距离是非负的

    // convert a distance in yards, feet, and inches to inches
    std::cout << "Enter a distance as yards, feet, and inches "
            << "with the three value separated by space: ";

    std::cin >> yards >> feet >> inches;  // 分别输入 码、英尺、英寸


    const unsigned int feet_per_yard {3};    // 每码 3 英尺
    const unsigned int inches_per_foot {12}; // 每英尺 12 英寸

    unsigned total_inches {};  // 总英寸
    total_inches = inches + inches_per_foot * (yards * feet_per_yard + feet);
    std::cout <<"This distance corresponds to " << total_inches << " inches.\n";

    // convert a distance in inches to yards, feet, and inches
    std::cout << "Enter a distance in inches: ";
    std::cin >> total_inches;

    feet = total_inches / inches_per_foot;
    inches = total_inches % inches_per_foot;
    yards = feet / feet_per_yard;
    feet = feet % feet_per_yard;

    std::cout << "This distance corresponds to "
    << yards << " yards "
    << feet << " feet "
    << inches << " inches " << std::endl;
    return 0;
}
```

这个示例程序的典型输出如下

```shell
Enter a distance as yards, feet, and inches with the three value separated by space:9 2 11

This distance corresponds to 359 inches.
Enter a distance in inches:359

This distance corresponds to 9 yards 2 feet 11 inches
```

在 `main()` 中的第一条语句定义了 $3$ 个整型变量，并把它们初始化为 $0$。它们的类型都是 `unsigned int`，这是因为距离是非负的。然后，定义了 `feet_per_yard` 和 `inches_per_foot` 分别用于将码、英尺和英寸统一转换为英寸；这两个变量的值是固定的，所以将它们声明为 `const` 的

### 增强赋值

对于下面的语句有一种更简略的形式

```cpp
feet = feet % feet_per_yard;
```

这条语句可以用增强赋值运算符来编写；增强赋值运算符是由一个运算符和一个赋值运算符组成

```cpp
feet %= feet_per_yard;
```

这条语句和上一条语句完全等价。增强赋值运算符的一般形式形式如下

```cpp
lhs op= rhs;
```

其中 `lhs` 代表某个变量，用于存储该运算符执行的结果。`rhs` 是一个表达式。这等价于语句

```cpp
lhs = lhs op (rhs);
```

::: info
这里这个圆括号很重要，例如

```cpp
x *= y + 1;
```

等价于

```cpp
x = x * (y + 1);
```

:::


下表中列出来了在 C++ 中支持的增强赋值运算符

|操作|运算符||操作|运算符|
|:---|:---|:---|:---|:---|
|加法|`+=`||位与|`&=`|
|减法|`-=`||位或|`\|=`|
|乘法|`*=`||异或|`^=`|
|除法|`/=`||左移|`<<=`|
|模运算|`%=`||右移|`>>=`|

::: warning 警告
请注意 `op` 和 `=` 之间是没有空格的。如果包含空格，就会出现错误
:::

## 递增递减运算符

增强赋值运算符 `+=` 和 `-=` 也可以用于让整数变量进行递增和递减。然而，C++ 为这两个操作专门设计了两个运算符 `++` 和 `--`。例如

```cpp
int count {5};
count = count + 1;  // 现在 count 的值是 6
count += 1;         // 现在 count 的值是 7
++count;            // 现在 count 的值是 8
```

上面的三条语句都可以让整数变量递增 $1$。显然，使用 `++` 运算符是最简单的。`++count` 表达式的结果是修改后的 `count` 的值。例如；假设 `count` 的值是 $5$

```cpp
total = ++count + 6;
```

`++` 和 `--` 运算符的优先级要比其他二元算术运算符的优先级更高，因此 `count` 的值先递增 $1$ 变为 $6$，而表达式 `++count` 的值就是 `cout` 递增后的结果 $6$。所以，表达式 `total = ++count + 6` 最终的结果是 $12$

::: tip
这里，我们使用的是 `++` 和 `--` 运算符的前缀形式。在前缀形式中，先递增或者递减变量的值，最后才计算整个表达式的值(即，被递增或递减变量的值)

此外，它们还有后缀形式。与前缀形式不同的地方在于：后缀形式先计算表达式的值，最后才递增或递减变量的值
:::

例如，把前面的例子改为

```cpp
total = count++ + 6;
```

`count` 的初始值还是假设为 $6$，但是 `total` 的值应该是 $11$，`cout` 再递增为 $6$。因此，上述语句等价于

```cpp
total = count + 6;
++count;
```

**不要再代码中出现 `a++ + b` 或者 `a+++b` 等含义不清晰的代码，这可能导致编译器不知道该怎么解析这个表达式**。对于复杂的表达式，请添加括号确保表达式的含义明确。例如：

```cpp
total = (count++) + 6;
```

::: warning 警告
不要在一个表达式中对给定的变量多次使用 `++` 或 `--` 运算符。否则，程序执行的结果完全依赖于编译器
:::

例如，假设变量 `count` 的值为 $5$，对于语句

```cpp
total = ++count * 3 + count++ * 5;
```

由于 C++ 标准并未规定表达式的求值顺序，在上述语句中，如果 `++count` 先执行时，结果为 $48$；如果 `count++` 先执行时，结果为 $46$

::: info
`++` 和 `--` 运算符通用用于整数，尤其是在循环语句中使用
:::


## 定义浮点变量

在 [第一章 基本概念#存储浮点数](./001-基本概念.md#存储浮点数) 中介绍了计算机是如何存储浮点数的。现在，我们来学习在 C++ 中如何声明浮点数类型的变量

当希望使用非整数值时，可以使用浮点变量。浮点变量的数据类型有 $3$ 中

|数据类型|描述|
|:---|:---|
|`float`|单精度浮点数|
|`double`|双精度浮点数|
|`long double`|扩展双精度浮点数|

::: warning
对于浮点数类型，不能使用 `unsigned` 或者 `signed` 修饰；浮点数总是带符号的
:::

**精度** 是指浮点数表示中 **尾数** 的位数。上述表格中，从上到下类型的精度逐步增加。**精度只能确定尾数中的位数**，某一类型表示的值域主要由指数的可能范围确定

C++ 标准并没有规定精度和数值范围，所以这取决编译器实现，也取决于计算机使用的处理器类型及其使用的浮点数表示方法。不过，C++ 标准要求 `long double` 提供的精度不小于 `double` 类型提供的精度，`double` 类型提供的精度不小于 `float` 类型提供的精度

现在，几乎所有的编译器和计算机架构都按照 IEEE 754 binary 规定的浮点数和浮点数运算。

|类型|精度(十进制尾数)|取值范围(+或-)|
|:---|:---|:---|
|`float`| $7$ |$\pm 1.18 \times 10^{-38} \sim \pm 3.4 \times 10^{38}$|
|`double`| $15$ |$\pm 2.22 \times 10^{-308} \sim \pm 1.8 \times 10^{308}$|
|`long double`| $18$ 或 $19$ |$\pm 3.65 \times 10^{-4932} \sim \pm 1.18 \times 10^{4932}$|

下面是一些定义浮点数变量的语句

```cpp
float pi{3.1415926f};

double inches_to_mm{25.4};

long double root2 {1.4142135623730950488L};
```

## 浮点字面值

在浮点字面值中，指数是可选的，表示 $10$ 的幂乘以该值。指数必须带有前缀 `e` 或者 `E`，其后是指数值

```cpp
5E3(5000.0)     100.5E2(10050)      2.5e-3(0.0025)      -0.1e-3L(-0.0001L)
```

浮点数字面值默认情形下是 `double` 类型；如果需要指定 `float` 类型的字面值，需要添加后缀 `f` 或者 `F`；为 `long double` 字面值添加后缀 `l` 或者 `L`

## 浮点数的计算

浮点支持的计算与整数计算相同。例如

```cpp
const double pi {3.141592653589793};

double a {0.2};
double z {9};
double volume {};
volume = pi * z * z * a;
```

::: warning 警告
运算符 `%` 不能用于浮点数操作，其他二元算术运算符，例如 `+` `-` `*` 和 `/` 都可以用于浮点数。

对于浮点数变量也可以使用 `++` 或者 `--`，其作用是递增 `1.0` 或者递减 `1.0`
:::

### 数学常量

在上一个示例中，使用自定义的常量 `pi` 计算了一个披萨的体积

```cpp
const double pi {3.141592653589793};
```

但这个常量数字还有其他的一些应用。可以使用它计算其他物体的体积。现在，开发人员就不必重新发明这个轮子。因此，在 C++20 标准库中，开发人员终于提供了一个 `<numbers>` 模块，其中定义了这个常量 $\pi$ 和其他几个通用的数学常量。下表列出来几个常用的常量，完整的请参阅标准库文档

|常量|描述|近似值|
|:---|:---|:---|
|`std::numbers::e`|自然常数|$2.71828\cdots$|
|`std::numbers::pi`|$\pi$|$3.14159\cdots$|
|`std::numbers::sqrt2`|$2$ 的平方根|$1.41421\cdots$|
|`std::numbers::phi`|黄金比例常量$\phi$|$1.618\cdots$|

这些常量都是 `double` 类型。如果计算中需要这些常量具有 `float` 或者 `long double` 精度，则应该使用 `std::numbers::pi_v<float>` 或者 `std::numbers::sqrt2_v<long double>` 形式的表达式。也就是说，在常量名后添加 `_v<T>` 后缀，用所希望的浮点类型替换 `T`

### 数学函数

在 `<cmath>` 标准库头文件定义了许多可以在程序中使用的数学函数。如今，在 `<cmath>` 头文件中定义了各式各样的数学函数，既包含非常基本的数学函数，也包含非常高级的数学函数；例如，C++17 标准添加了柱函数中的诺伊曼函数、拉盖尔多项式和黎曼 `zeta` 函数。可以查阅标准库参考手册了解完整的数学函数

下表列出了这个头文件最有用的函数。所有函数名都在 `std` 名字空间中定义。除非另外说明，否则 `<cmath>` 头文件中的所有函数都接收任意浮点类型或整型参赛。函数的结果总是与浮点型参数的类型相同，对于整型参数，结果为 `double` 类型

|函数|说明|
|:---|:---|
|`abs(arg)`|返回 $\vert {arg} \vert$。注意，`arg` 是整型时 `abs()` 的返回值也是整型|
|`ceil(arg)`|返回 $\lceil arg \rceil$。`ceil(2.5)` 返回 `3.0`；`ceil(-2.5)` 返回 `-2.0` |
|`floor(arg)`|返回 $\lfloor arg \rfloor$。`floor(2.5)` 返回 `2.0`；`floor(-2.5)` 返回 `-3.0`|
|`exp(arg)`|返回 $e^{arg}$|
|`log(arg)`|返回 $\ln{arg}$|
|`log10(arg)`|返回 $\log_{10}{arg}$|
|`pow(arg1, arg2)`|返回 $arg1^{arg2}$|
|`round(arg)`|将 `arg` 四舍五入到最接近的整数|
|`lround(arg)`|将 `arg` 四舍五入到最接近的整数|
|`llround(arg)`|将 `arg` 四舍五入到最接近的整数|

此外，`<cmath>` 头文件还提供了全部的基本三角函数，以及它们的反函数

::: warning
请注意：`<cmath>` 头文件源自于 C 标准库，所以不能保证可将 C 头文件作为模块导入。要使用其功能可用于源代码，就需要使用 `#include` 指令

```cpp
#include <cmath>
```

与 `#include` 声明不同，`#include` 指令后不能有分号。另外，不要忘记前面的符号 `#`
:::

下面是一个浮点示例。假定要构建一个圆形的池塘来养鱼。通过研究发现，必须保证该池塘的表面积为 $2$ 平方英尺，才能确保每条鱼有 $6$ 英寸长。本例需要确定池塘的直径，以确保鱼有足够的空间。下面就是实现过程

```cpp title="diameter.cpp"
// diameter.cpp
// 池塘的直径
#include <iostream>
#include <numbers>

#include <cmath>

int main() {
    const double fish_factor {2.0 / 0.5};
    const double inches_per_foot { 12.0 };  // 1英尺 = 12 英寸

    // 存储用户输出变量
    double fish_count {};  // 养鱼的数量
    double fish_length {}; // 鱼的体长（英寸）

    std::cout << "Enter the number of fish you want to keep: ";
    std::cin >> fish_count;
    std::cout << "Enter the average of fish length in inches: ";
    std::cin >> fish_length;
    fish_length /= inches_per_foot;  // 转换为英尺
    std::cout << '\n';

    // 圆形池塘的面积（平方英尺）
    const double pond_area {fish_count * fish_length * fish_factor};
    // 圆形池塘的面积 pi * r * r => 计算池塘的直径 r = sqrt(area / pi)
    const double pond_diameter {2.0 * std::sqrt(pond_area / std::numbers::pi)};

    std::cout << "Pond diameter required for " << fish_count << " fish is " << pond_diameter << " feet.\n";
    return 0;
}
```

### 无效的浮点数值

根据 C++ 标准，除以 $0$ 的结果是不确定的。但是，大部分计算机上，硬件的浮点操作都是根据 IEE 754 标准实现的。因此，把浮点数除以 $0$ 的时候，编译器一般会表现出类似的行为。不同的编译器在细节上可能有区别，所以应该查询编译器手册了解细节

IEEE 浮点数标准定义了几个特殊值，参考 [第一章 基本概念#存储浮点数](001-基本概念.md#存储浮点数)。下表列出来特殊值 `infinity` 和 `NaN` 的操作

|操作|结果||操作|结果|
|:---|:---|---|:---|:---|
|$\pm \text{value} / 0$|$\pm \text{infinity}$||$0 / 0$|$\text{NaN}$|
|$\pm \text{infinity} \pm \text{value}$|$\pm \text{infinity}$||$\pm \text{infinity} / \pm \text{infinity}$|$\text{NaN}$|
|$\pm \text{infinity} * \text{value}$|$\pm \text{infinity}$||$\text{infinity} - \text{infinity}$|$\text{NaN}$|
|$\pm \text{infinity} / \text{value}$|$\pm \text{infinity}$||$\text{infinity} * 0$|$\text{NaN}$|

::: tip
上表中的 $\text{value}$ 都是任意非 $0$ 值
:::

### 缺点

使用浮点数不小心时，可能会导致计算结果不正确。下面是使用浮点数时常见的错误原因

+ **一些小数值没有准确转换为二进制浮点数值**。在计算过程中，很容易把一些小错误放大为大错误
+ **计算两个非常接近的数值之差会丧失精度**。如果考虑两个浮点数值之差，而这两个数值仅在第 $6$ 位的数字上有区别，那么其结果是只有一或两位是精确的，其他位则可能出错
+ **处理范围相差几个数量级的数值会导致错误**。例如，将两个 `float` 类型的浮点数相加，其中一个值是相对于另一个值的 $10^8$ 倍，将较小值加到较大值上任意次，较大值是不会有变化的

## 混合的表达式和类型转换

在 C++ 中，表达式可以包含不同类型的操作数。例如，示例程序 `diameter.cpp` 中可以定义整型变量来存储鱼数量

```cpp
unsigned int fish_count {};  // 鱼的数量
```

鱼的数量肯定是整数，所以这是有效的。一英尺的英寸数也是整数，所以可以定义如下变量

```cpp
const unsigned int inches_per_foot {12};  // 1 英尺 = 12 英寸
```

即使变量有不同的类型，计算也是可以完成的，例如

```cpp
fish_length /= inches_per_foot;  // 转换为英尺
double pond_area {fish_count * fish_length * fish_factor};  // 池塘的表面积
```

从技术上讲，**二元运算符要求两个操作数的类型相同**。如果它们的类型不同，编译器就必须生成额外的代码将其中一个操作数转换为另一个操作数的类型。这称为 **隐式类型转换**

::: tip
隐式类型转换的工作方式就是把值域较小的类型的值转换为另一个值域较大的类型的值。转换前与转换后的值必须相等；如果转换导致信息丢失，称为窄化类型转换
:::

例如语句 `fish_length /= inches_per_foot;` 中，变量 `fish_length` 的类型是 `double`，变量 `inches_per_foot` 的类型是 `unsigned int`。`double` 类型的值域远大于 `unsigned int` 类型的值；因此，编译器会插入一个转换操作，将 `inches_per_foot` 变量的值转换为 `double` 类型的值

::: warning 警告
类型转换会产生一个全新的对象，并不会修改变量本身的类型
:::

在操作数类型不同的 **算术表达式** 中，编译器会选择把值域更为受限的操作数转换为另一个操作数的类型。基本上，编译器按照如下顺序从高到低对类型进行排序，**优先向高级类型进行转换**

|等级|类型||等级|类型||等级|类型|
|:---|:---|---|:----|:----|---|:----|:----|
|1|`long double`||4|`unsigned long long`||7|`long`|
|2|`double`||5|`long long`||8|`unsigned int`|
|3|`float`||6|`unsigned long`||9|`int`|

大致上，就是将值域小的类型的值转换值域大的类型。通常，有符号数整数与无符号数整数在一个表达式中时，有符号整数会被隐式转换为无符号整数；这往往会导致一些问题的出现。例如

```cpp
unsigned int x {20u};
int y {30};

std::cout << x - y << std::endl;
```

上述代码片段的期待输出是 $-10$，然而并不是我们想要的结果。因为变量 `y` 的值被隐式转换为了 `unsigned int` 类型，因此 `x - y` 表达式的类型就是 `unsigned int`，所以表达式求值的结果类型是 `unsigned int`。由于无符号整数类型不能表示 `-10`，对于结果小于 $0$ 的值总会被移位可能得到的最大整数值。

::: tip
无符号整数减法的结果会被移位成极大值，这种现象称为 **下溢**。自然，也存在 **上溢** 的现象。例如，将 `unsigned char` 类型的值 `253` 加上 `5`，最终得到的结果是 `2`，而不是我们期望 `258`；这是因为 `unsigned char` 类型最大只能存储 `255`。这个加法操作的结果是 `2`，即 `258 % 256`
:::

::: warning 警告
只有无符号整数类型的上下溢出的结果是确定的。有符号整型变量，超出其能表示的范围时结果是不确定的，取决于编译器和计算机体系结构
:::

在 **赋值表达式** 中，如果赋值符号左右操作数的类型不同，编译器也会插入隐式转换操作，将右操作数的类型的值转化为左操作数的类型。例如

```cpp
int y {};
double z {5.2};

y = z; // 编译器会将 z 的值转换为 int 类型，在赋值给 y
```

::: warning 警告
在编写程序时，操作数类型不同的表达式不要简单的依赖于编译器类型转换，除非结果是确定的。如果不能确定，可以使用 **显式类型转换**，也称为 **强制类型转换**
:::

## 显式类型转换

要把表达式的值显示转换为给定类型，应该使用如下格式的转换语句

```cpp
static_cast<target_type>(expression);  // 将 expression 的值的类型转换为 target_type
```

关键字 `static_cast` 表示这个强制类型转换要进行静态检查，也就是说，在程序编译时进行检查。`static_cast` 通常用于反转隐式类型转换。例如，将 `double` 类型的值转换 `int` 类型

```cpp
int y {};
double z {5.0};

y = static_cast<int>(z);  // 将 double 类型的值转换为 int 类型
```

::: tip
如果 `expression` 的类型不存在向 `target_type` 的隐式类型转换，则 `static_cast` 转换被禁止
:::

通过添加显式类型转换，可以告诉编译器窄化类型转换时故意执行的。如果转换不是窄化类型转换，就不必添加显式类型转换。例如

```cpp
double value1 {10.9};
double value2 {15.9};

int whole_number { static_cast<int>(value1) + static_cast<int>(value2) }; // 25
```

::: warning 注意
与整数除法相同，将浮点数强制转换为整数会进行截断，即 **丢弃浮点数的小数部分**
:::

一般情况下，很少需要显示类型转换，特别是在数据为基本类型时。如果必须在代码中包含大量的显示类型转换，则通常表明应为变量选择更合适的类型。但是，仍有一些情况需要进行显式类型转换。例如，下面的示例程序将单位为码的长度(浮点数)转换为 码、英尺、英寸

```cpp title="conversions.cpp"
// conversions.cpp
// 显示类型转换演示程序
#include <iostream>


int main() {
    const unsigned feet_per_yard {3};  // 1 码 = 3 英尺
    const unsigned inches_per_foot {12}; // 1 英尺 = 12 英寸
    const unsigned inches_per_yard {feet_per_yard * inches_per_foot};  // 1 码 = 3 * 12 英寸

    double length{};         // 长度：码
    unsigned int yards{};    // 码
    unsigned int feet{};     // 英尺
    unsigned int inches{};   // 英寸

    std::cout << "Enter a length in yards as a decimal: ";
    std::cin >> length;

    // 从 length 中 提取 yards 码 feet 英尺 inches 英尺
    yards = static_cast<unsigned int>(length);  // length 的整数部分
    feet = static_cast<unsigned int>((length - yards) * feet_per_yard); // length - yards: length 的小数部分
    inches = static_cast<unsigned int>(length * inches_per_yard)  % inches_per_foot;

    std::cout << length << " yards converts to "
             << yards << " yards "
             << feet << " feet "
             << inches << " inches" << std::endl;
    return 0;
}
```

上述代码编译运行的结果为

```shell
Enter a length in yards as a decimal:2.75

2.75 yards converts to 2 yards 2 feet 3 inches
```

::: info C风格的强制类型转换
在 C++98 引入 `static_cast` 之前，使用的 C 风格强制类型转换

```cpp
(target_type)(expression);  // 将 expression 的值的类型转换为 target_type
```

这种显示类型转换是没有约束的，可以完成所有的类型转换，即使时不兼容的类型也能转换成功。在现代 C++ 开发中，尽量避免这种行为
:::

## 格式化字符串

在示例代码 `diameter.cpp` 中，对于平均体长 $9$ 英寸的 $20$ 条鱼，得到下面的输出

```shell
Pond diameter required for 20 fish is 8.74039 feet.
```

可以使用流操作程序改变输出流数据的格式。要应用流操作程序，需要使用 `<<` 运算符，把流输出程序和数据一起插入输出流中。例如，我们标准模块 `<iomanip>` 中的 `std::setprecision()` 操作程序时，可以调整输出流在格式化浮点数时使用的小数位精度

```cpp
std::cout << "Pond diameter required for "
        << fish_count << " fish is "
        << std::setprecision(2) << pond_diameter << " feet.\n";  // setprecision(2) 设置浮点数精度(有效数字位数)为 2
```

标准模块 `<ios>` 和 `<iomanip>` 中定义了许多流操作程序。下表列出来常用格式化操作

|流操作函数|描述|
|:---|:---|
|`std::hex`|整数显示为十六进制|
|`std::scientific`|浮点数显示为指数形式|
|`std::setw`|设置宽度|
|`std::setprecision`|设置浮点数精度|

::: warning 注意
关于流操作函数请参考 [iomanip](https://en.cppreference.com/w/cpp/io/manip.html)。我们主要介绍 `std::format()`，这是 C++20 中提供的更强大的函数
:::

```cpp
std::cout << std::format("Pond diameter required for {} fish is {} feet.\n",
                        fish_count, pond_diameter);
```

### 格式说明符

`std::format()` 函数的第一个实参总是 **格式化字符串**。这个字符串包含任意数量的替代字段，用花括号 `{}` 表示。格式化字符串之后跟随至少 $0$ 个实参，一般每个替代字段对应这样一个实参。在我们的示例中，有两个额外的实参 `fish_count` 和 `pond_diameter`。因此，`std::format()` 的结果是复制格式字符串，并将每个替代字段替换为相应实参的文本表示

在替代字段 `{}` 中，可以指定一系列的格式说明符。这些格式说明符以 `:` 开始。对于基本类型和字符串类型的替代字段，其格式说明如下

```cpp
{:[[填充字符]对齐方式]['+' 或者 ' '][#][0][最小宽度][.精度][类型]}
```

::: tip
其中，方括号表示这些格式说明符是可选的。**如果指定格式说明符，那么冒号也是不需要的**
:::

格式说明符告诉 `std::format()` 要如何格式化对应的数据。例如，要调整浮点数的精度，可以在花括号中间填入 `:.精度` 接口

```cpp
std::cout << std::format("Pond diameter required for {} fish is {:.2f} feet.\n",
                        fish_count, pond_diameter);
```

### 格式化表格数据

在格式说明符中，`[[填充字符]对齐方式]` 和 `[0][最小宽度]` 四部分内容用于控制每个替代字段的宽度和对齐方式。其中

::: tip
`最小宽度` 是一个正整数。在需要时，会在被格式化的字段中插入额外的字符来达到这个最小宽度。至于插入何种字符以及在什么位置插入字符取决于字段类型，以及其他格式选项

对于字段类型是数字类型时，如果 `最小宽度` 前带有 `0`，则在数字之前、任何符号字符(`+`或`-`)或者前缀(`0x` 或 `0b`) 之后，插入额外的字符 `0`

否则，插入 `填充字符`。默认情况下，填充字符是空格。`对齐方式` 决定了在什么位置插入填充字符。可选值的对齐方式包括：左对齐(`<`)、右对齐(`>`) 和 居中对齐(`^`)
:::

来看下面的示例代码

```cpp title="format_table.cpp"
// format_table.cpp
// 格式化表格数据

#include <iostream>
#include <format>

int main() {
    // 默认情况下，数字左对齐，其他的右对齐
    std::cout << std::format("{:7}|{:7}|{:7}|{:7}|{:7}\n", 1, -0.2, "str", 'c', true);
    // 填充字段
    std::cout << std::format("{:*<7}|{:*<7}|{:*>7}|{:*>7}|{:*>7}\n", 1, -0.2, "str", 'c', true);
    // 居中对齐
    std::cout << std::format("{:*^7}|{:*^7}|{:^7}|{:*^7}|{:*^7}\n", 1, -0.2, "str", 'c', true);
}
```

编译上述代码并运行的结果为

```shell
$ g++ -std=c++23 -fmodules-ts -xc++-system-header iostream
$ g++ -std=c++23 -fmodules-ts -xc++-system-header format
$ g++ -std=c++23 -fmodules-ts .\table.cpp -o .\table.exe
$ .\table.exe
      1|   -0.2|str    |c      |true
1******|-0.2***|****str|******c|***true
***1***|*-0.2**|  str  |***c***|*true**
```

### 格式化数字

剩余的 $4$ 个格式选项 `['+' 或者 ' '][#][.精度][类型]` 主要用于格式化数字。

::: tip
格式化浮点数时，可以指定 `.精度` 和 `类型`。其中，类型可选的则 `f`(定点形式) `e`(指数形式) `g`(常规形式) `a`(十六进制形式)

格式化整数时，不允许指定 `.精度`。但是，可以指定类型选项 `b`(二进制形式) `x`(十六进制形式)。如果添加选项 `#`，会附加特定的前缀，包括 `0b`(二进制形式前缀) `0x`(十六进制形式前缀)

如果在格式化数字时，指定了符号 `+`，对于正数，将在数字前附加符号 `+`
:::

来看下面的示例代码

```cpp title="format_number.cpp"
// format_number.cpp
// 格式化数字数据
#include <iostream>
#include <format>
#include <numbers>

int main() {
    // 浮点数
    const double pi = std::numbers::pi;
    std::cout << std::format("Default: {:.2}, fixed: {:.2f}, scientific: {:.2e}, general: {:.2g}\n", pi, pi, pi, pi);
    // 整数
    std::cout << std::format("Default: {}, binary: {:b}, octal: {:o}, hex: {:x}\n", 314, 314, 314, 314);
    std::cout << std::format("Default: {}, decimal: {:d}, hex: {:x}\n", 314, 314, 314);
    std::cout << std::format("Forced sign: {:+}, space sign: {: }\n", 314, 314);
    std::cout << std::format("All together: {:*<+10.4f}, {:+#09x}\n", pi, 314);
}
```

编译上述代码并运行的结果为

```shell
$ g++ -std=c++23 -fmodules-ts -xc++-system-header iostream
$ g++ -std=c++23 -fmodules-ts -xc++-system-header format
$ g++ -std=c++23 -fmodules-ts -xc++-system-header numbers
$ g++ -std=c++23 -fmodules-ts .\number.cpp -o .\number.exe
$ .\number.exe
Default: 3.1, fixed: 3.14, scientific: 3.14e+00, general: 3.1
Default: 314, binary: 100111010, octal: 472, hex: 13a
Default: 314, decimal: 314, hex: 13a
Forced sign: +314, space sign:  314
All together: +3.1416***, +0x00013a
```

### 参数索引

注意，格式说明符都是使用 `:` 开头的，这是为什么呢？原因在于，`std::format()` 函数允许指定格式字段在参数列表中的索引。

```cpp
std::cout << std::format("Default: {0:.2}, fixed: {0:.2f}, scientific: {0:.2e}, general: {0:.2g}\n", pi);
```

::: tip
C++20 引入的 `std::format()` 函数与 Python 中字符串的 `str.format()` 方法类似。参考 [Python-字符串格式化](https://docs.python.org/zh-cn/3.14/tutorial/inputoutput.html#the-string-format-method) 了解更详细的内容
:::

## 确定数值的范围

在前面的内容中，我们介绍整数类型和浮点数类型以及它们占用的内存大小。C++ 标准模块 `<limits>` 中包含了所有基本类型的上下限信息。例如，我们可以查看 `double` 类型表示的最大值

```cpp
std::cout << "Maximum value of double: " << std::numeric_limits<double>::max() << std::endl;
```

表达式 `std::numeric_limits<type>::max()` 用于返回 `type` 类型能够表示的最大值。此外，还可以使用 `min()` 获取最小值。但是，对于整数和浮点数 `min()` 的含义并不相同

::: tip
对于浮点数而言，`std::numeric_limits<type>::min()` 返回的是最小正值

对于整数而言，`std::numeric_limits<type>::min()` 返回的是最小值
:::

因此，如果需要获取浮点数类型的最小值，需要使用 `std::numeric_limits<type>::lowest()` 返回的是浮点类型最小值

除了获取数值类型的范围外，还可以获取一些基本属性。例如

+ `std::numeric_limits<type>::digits`：获取 `type` 占用的位数
+ `std::numeric_limits<type>::infinity()`: 获得特殊值浮点数的 `infinity`
+ `std::numeric_limits<type>::quiet_NaN()`: 获得特殊值浮点数的 `NaN`

至于其他额外的函数，参考标准库手册即可

## 使用字符变量

`char` 类型的变量主要用于存储单个字符的编码。关于字符编码，请参考 [第一章 基本概念#表示字符](001-基本概念.md#表示字符)。在 C++ 中，`char` 类型占用 $1$ 字节，虽然 C++ 标准没有指定用于表示基本字符集的字符编码，所以原则上是由编译器指定的，但一般使用 ASCII 编码

::: tip
在 C++ 中，`char` 类型只能存储那些只占用 $1$ 字节编码的字符。例如 ASCII 编码、Latin-1 编码等
:::

`char` 类型的变量声明与其他类型的变量声明相同，例如

```cpp
char letter;                // 未初始化
char yes {'y'}, no {'n'};   // 使用字符字面值初始化
char ch {33};               // 使用字符编码初始化。编码为 33 的字符是 '!'
```

`char` 类型的变量可以用放在 **单引号** 中的字符字面量或者整数进行初始化。整数初始化器必须位于 `char` 类型的值域内

::: warning
这取决于编译器对 `char` 类型的实现。有些编译器将 `char` 类型实现为有符号，有些编译器将 `char` 类型实现为无符号的
:::

此外，还允许使用 [字符转义序列](001-基本概念.md#转义序列)。然而，有些字符无法从键盘输入，并且也不存在于字符转义序列中。对于这种字符可以使用 **八进制** 或在 **十六进制** 表示的字符编码

::: tip
八进制字符编码转义序列表示为 `'\ooo'`，其中每个 `o` 代表了一个八进制数。对于只占用 $1$ 字节的 `char` 类型来说，八进制字符编码转义序列最大只能为 `'\377'`

十六进制字符编码转义序列表示为 `'\xhh'`，其中每个 `h` 代表了一个十六进制数。请注意：C++ 标准并未规定十六进制字符编码转义序列中十六进制数的个数。但是，对于只占用 $1$ 字节的 `char` 类型，十六进制字符编码转义序列最大只能为 `'\xFF'`
:::

`char` 类型的变量是数值，它们存储的是表示字符的整数代码，因此它们可以参与算术表示，就像 `int` 或者 `long` 类型的变量一样

```cpp
char ch {'A'};
char letter {ch + 2};  // 'C'
++ch;                  // 'B'
ch += 3;               // 'E'
```

在使用 `std::cout` 或者 `std::format()` 写入 `char` 类型变量时，默认输出的是字符而不是整数。如果需要输出整数请进行显式类型转换，或者使用格式化说明符 `d, o, x`

```cpp
std::cout << std::format("ch is '{0}' which is code {0:#x}\n", ch);
```

### 使用 Unicode 字符

`char` 类型对于使用拉丁文的国家完全够用。但是，如果要同时使用多种语言的字符，或者要处理非拉丁文的字符，$1$ 字节就完全不够用了。例如，Unicode 字符就是采用 $2$ 字节编码的字符集，既是在 [第一章 基本概念#ucs 和 unicode](./001-基本概念.md#ucs-和-unicode) 中介绍的字符编码

在 C++ 中，使用 `wchar_t` 类型的变量来存储那些编码超过 $1$ 字节的字符，它可以存储实现方式支持的最大扩展字符集中的所有乘以

::: note
`wchar_t` 类型的名字来自于 **宽字符(wide character)**，因为字符的范围比通常的单字节字符宽
:::

定义宽字符字面值的方式与 `char` 类型类似，只是需要再字面值前面加上前缀 `L'`

```cpp
wchar_t z {L'Z'};
```

键盘上可能没有表示某些字符的按键，但是仍然可以使用十六进制表示法创建它们。

```cpp
wchar_t cc {L'\x00E7'};
```

::: warning 警告
`wchar_t` 类型的大小完全依赖于具体实现，编译器针对宽字符字面量使用的编码方式也是如此。它们通常对应于目标平台首选字符编码。因此，对于 Windows 平台，`wchar_t` 通常是 $16$ 位，使用 UTF-16 对宽字符字面量进行编码；对于其他多数平台，`wchar_t` 通常是 $32$ 位，使用 UTF-32 对宽字符字面值进行编码
:::

换句话说，使用 `wchar_t` 编写的代码是不可移植的。因此推荐使用 `char8_t` `char16_t` 和 `char32_t`。这些类型分别把字符存储为 UTF-8、UTF-16 和 UTF-32，并且它们的大小在所有的通用平台上都相同。例如

```cpp
char8_t yen {u8'\x00A5'};
char16_t delta {u'\u0394'};
char32_t ya {U'\u044f'};
```

字面量的前缀 `u8` `u` `U` 分别表示 UTF-8、UTF-16 和 UTF-32。

::: note
`char6_t` 类型是 C++20 中引入的。因此，大多数老式的代码和库还是使用类型 `char` 表示 UTF-8 编码的字母
:::

## auto 关键字

使用 `auto` 关键字可以告诉编译器应推断变量的类型。例如

```cpp
auto m {10};                // m 的类型是 int
auto n {200UL};             // n 的类型是 unsigned long int
auto p {std::numbers::pi};  // p 的类型是 duouble
```

编译器会根据提供的初始值推断变量的类型。请注意：在定义基本类型的变量时，请显式指定变量的类型。`auto` 关键字设计意图并不在这里

::: warning 警告
给`auto` 关键字使用初始化列表时需要非常谨慎。假设编写如下代码

```cpp
auto m = {10};  // m 的类型是 std::initializer_list<int>
```

这里变量 `m` 的类型被推断为 `std::initializer_list<int>` 而不是 `int`。这种列表通常用于指定容器的初始值。

在 C++17 之后，类型推断规则发生了变化。例如

```cpp{3}
auto i {10};                // int
auto pi = {3.14};           // std::initializer_list<double>
auto list1{1,2,3,4};        // error // [!code focus]
auto list2 = {1,2,3,4};     // std::initializer_list<int>
```

为了可移植性，请遵循一个准则：**auto不应该使用初始化列表，而应该使用 C 风格初始化器或者函数式初始化器**
:::
