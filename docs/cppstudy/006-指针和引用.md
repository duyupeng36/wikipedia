---
title: 指针和引用
createTime: 2025/11/18 21:17:57
permalink: /cppstudy/pl6nd91k/
---

指针与引用的概念比较相似，因此我们将其放在一起介绍。指针非常重要，是 C++ 语言的核心概念之一，理解指针是学好 C++ 的关键。在 C++ 中，指针与数组的关系也非常紧密，因此我还会站在指针的视角解释数组

## 什么是指针

程序中的每个变量和函数都位于内存的某个地方，所以都有独特的地址来标识它们存储的位置。这些地址取决于运行程序时将程序加载到内存的什么地方，所以程序每次运行时，这些地址都有可能不同。

**指针是可以存储地址的变量**。存储在指针中的地址可以是变量或者其他数据的地址。下图说明了指针这名字的由来：它指向内存中存储其他值的位置

![1763834364485-b92a41a121e7716cb5ccddec8d9f1451.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1763834364485-b92a41a121e7716cb5ccddec8d9f1451.png)

正如在 [第二章 基本数据类型](./002-基本数据类型.md) 中介绍的一样，整数的表示方法和浮点数完全不一样。因此，要使用存储于指针所指向的地址数据，还需要知道数据的类型。如果指针仅存储随意数据的内存地址，那么指针就没有什么意义了。因此，**使用指针时需要关注指针指向数据的数据类型**

在 C++ 中，指针的定义与普通变量的定义类似，但是在变量名之前需要加上一个星号(`*`)，表示该变量是一个指针。例如，下面的代码定义了一个指向整数的指针变量 `p`：

```cpp
long *p;  // 指针 p 指向一个 long 类型的数据所在的内存
```

变量 `p` 的类型是 `long*`，表示它是一个指向 `long` 类型数据的指针。注意，`long*` 和 `long` 是两种不同的类型。该类型的变量只能存储 `long` 类型数据的地址。尝试存储其他非 `long` 类型数据的地址会导致编译错误。

::: tip

这里我们我们将星号与指针变量 `p` 紧挨在一起书写，表示在声明指针变量时 **星号是指针变量声明的一部分**，而不是类型的一部分。

:::

看下面的示例

```cpp
long *p, number;
```

这里定义了两个变量 `p` 和 `number`。变量 `p` 是一个指向 `long` 类型数据的指针，而变量 `number` 是一个普通的 `long` 类型变量。注意，只有变量 `p` 是指针类型，变量 `number` 不是指针类型。如果我们将星号(`*`)与类型 `long` 紧挨在一起书写，如下所示：

```cpp
long* p, number;
```

这可能会让人误以为 `p` 和 `number` 都是指针类型，但实际上只有 `p` 是指针类型，`number` 仍然是一个普通的 `long` 类型变量。因此，为了避免混淆，建议将星号(`*`)与指针变量名紧挨在一起书写。**当然最好的方式就一行只声明一个变量**，这样就不会出错

::: danger

注意，这里定义的指针变量 `p` 并没有初始化，它的值是未定义的，指向一个随机的内存地址。在使用指针之前，必须先将其初始化为一个有效的地址，否则会导致程序崩溃。

像这种执行未知地址的指针称为 **“野指针”(wild pointer)**。野指针非常危险，因此我们应该在指针变量被声明时就立即进行初始化。如果不想立即初始化指针变量，可以将其初始化为 `nullptr`，表示该指针不指向任何有效的地址

```cpp
long *p{nullptr};  // 指针 p 不指向任何有效地址
```

在使用指针变量时，请遵守黄金法则: **指针变量声明时立即初始化**

:::

可以把指针定义为任何类型，包括自定义类型。例如

```cpp
double *pvalue{};  // 基本类型

char16_t *pchar {};  // 自定义类型
```

不过，**无论指针指向什么类型或者大小的数据，指针变量本身的大小始终相同**。准确的说，在给定的平台上，所有指针变量都具有相同的大小。指针变量的大小取决于目标平台的可寻址内存的大小。下面的示例代码用于说明这个特性

```cpp title="pointer_size.cpp"
#include <iostream>

int main()
{
    std::cout << "Size of double: " << sizeof(double) << " bytes\n";
    std::cout << "Size of double pointer: " << sizeof(double*) << " bytes\n";
    std::cout << "Size of char: " << sizeof(char) << " bytes\n
    std::cout << "Size of char pointer: " << sizeof(char*) << " bytes\n";
    return 0;
}
```

该示例程序输出的内容为

```shell
Size of double: 8 bytes
Size of double pointer: 8 bytes
Size of char: 1 bytes
Size of char pointer: 8 bytes
```

无论是 `double` 还是 `char` 类型的指针变量，其大小均为 8 字节。这是因为该程序运行在一个 64 位的平台上，该平台的指针变量大小均为 8 字节。

## 地址运算符

地址运算符 `&` 是一个一元运算符，它可以获取变量的地址。例如，下面定义了一个变量 `number` 和一个指针变量 `p`，并将变量 `number` 的地址赋值给指针变量 `p`

```cpp
long number {42};  // 定义一个 long 类型变量 number 并初始化为 42
long *p (&number); // 定义一个指向 long 类型的指针变量 p，并将 number 的地址赋值给 p
```

表达式 `&number` 的值是变量 `number` 的地址，所以 `p` 存储了变量 `number` 的地址。现在，指针变量 `p` 指向变量 `number` 所在的内存位置。当然，也可以使用赋值语句将变量的地址赋值给指针变量

```cpp
long height {1454L};

p = &height;  // 将变量 height 的地址赋值给指针变量 p
```

::: tip

`&` 运算符可以应用于任何类型的变量，但必须在对应类型的指针中存储地址。例如，要存储 `double` 类型变量的地址，必须使用 `double*` 类型的指针变量

:::

当然，也可以使用 `auto` 关键字，让编译器自动推断类型。例如

```cpp

auto p {&number};  // p 的类型被推断为 long*

```

但是，建议使用 `auto *`，以便于在声明中能够清晰看出这里涉及指针。这里通过使用 `auto *`，定义了由编译器推断出来的指针类型的变量

```cpp
auto *p {&number};  // p 的类型被推断为 long*
```

请注意：使用 `auto *` 声明的变量只能使用指针初始化。使用其他类型的值初始化，编译器会报错

变量的地址已经被存储到指针变量中，我们关心的是如何通过地址操作其指向的内存中保存的数据。这可以使用间接运算符完成

## 间接运算符

间接运算符 `*` 应用于指针，可以访问指针所执行的内存位置的数据。间接运算符这个名称来自于数据的访问是间接的这一事实。该运算符也被称为解引用运算符，访问指针所指向的内存位置的数据的过程称为 **解除指针的引用**。要访问指针 `p` 所指向的地址中的数据，可以使用表达式 `*p`。通过如下示例程序来看指针的用法

```cpp title="pointer_example.cpp"
#include <iostream>
#include <format>

int main()
{
    int unit_price{ 295 };
    int count{};
    int discount_threshold{ 25 };
    double discount{ 0.07 };

    int* pcount{ &count };
    std::cout << "Enter the number of items you want: ";
    std::cin >> *pcount;
    std::cout << std::format("The unit price is ${:.2f}.\n", unit_price / 100.0);

    int* punit_price{ &unit_price };
    int price{ *pcount * *punit_price }; // [!code highlight]
    auto* pprice{ &price };

    double net_price{};
    double* pnet_price{ nullptr };
    pnet_price = &net_price;
    if (*pcount > discount_threshold)
    {
        std::cout << std::format("You qualify for a discount of {:.0f} percent.\n", discount * 100);
        *pnet_price = price * (1 - discount) / 100;
    }
    else
    {
        net_price = *pprice / 100;
    }
    std::cout << std::format("The net price for {} item is ${:.2f}.\n", *pcount, net_price);

    return 0;
}
```

该程序的运行结果如下

```shell
Enter the number of items you want: 50
The unit price is $2.95.
You qualify for a discount of 7 percent.
The net price for 50 item is $137.17.
```

表达式 `*pcount * *punit_price` 非常容易混淆。因为，运算符 `*` 有不同的含义。编译器可以根据上下文解析出星号(`*`) 的含义。。为了让代码更容易理解，这里设计多重含义的运算符时，可以使用圆括号，即 `(*pcount) * (*punit_price)`。这样可以清晰地表明这里的星号(`*`) 都是间接运算符。

## char 类型的指针

指向 `char` 类型的变量有一个有趣的属性，它可以用字符串字面值初始化。例如，下面的语句就声明并初始化了这样一个指针

```cpp
char *pproverb {"A miss is as good as a mile."};  // 不要这样做
```

这条语句看起非常类似于用字符串字面值初始化 `char` 数组，事实也确实如此。这条语句利用引号中的字符串创建了一个以空字符结尾的字符串字面值，并把字符串字面值中第一个字符的地址存储在 `pproverb` 中。如下图

![1763905778452-28beff1d90847bda3985359c69c4b2be.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1763905778452-28beff1d90847bda3985359c69c4b2be.png)

::: danger

字符串字面值是 C 风格的字符串，即 `char` 类型的数组，不应该该改变。也就是说，C 风格字符串的类型是 `const char[]`。但是，指针并没有反应出其所指向的内存区域是只读的这一点。这条语句并 **没有创建字符串字面值的可修改副本**，**只是存储了第一个字符的地址**。也就是说，如果尝试修改改字符串，就会出现问题

:::

为了反应出 C 风格字符串字面值是只读的，应该使用 `const char*` 类型的指针来存储字符串字面值的地址。例如

```cpp
const char *pproverb {"A miss is as good as a mile."};  // 推荐的做法
```

这条语句声明 `pproverb` 指针的类型是 `const char *` 类型，因为是 `const` 指针类型，所以能够与字符串字面值的类型保持一致。编译器也将阻止用这个指针对字符串字面值的字符进行赋值。关于 `const` 指针的更多内容将在后续章节中介绍。下面我们来看一个例子，在该例子中，使用 `const char *` 指针代替 `char[]` 数组

```cpp title="pointer_lucky_star.cpp"
#include <iostream>

int main()
{
    const char *pstar1 {"Fatty Arbuckle"};
    const char *pstar2 {"Clara Bow"};
    const char *pstar3 {"Lassie"};
    const char *pstar4 {"Slim Pickens"};
    const char *pstar5 {"Boris karloff"};
    const char *pstar6 {"Mae West"};
    const char *pstar7 {"Oliver Hardy"};
    const char *pstar8 {"Greta Garbo"};
    const char *pstr {"Your lucky star is "};
    std::cout << "Pick a lucky star! Enter a number between 1 and 8: ";
    size_t choice{};
    std::cin >> choice;

    switch (choice)
    {
        case 1: std::cout << pstr << pstar1 << ".\n"; break;
        case 2: std::cout << pstr << pstar2 << ".\n"; break;
        case 3: std::cout << pstr << pstar3 << ".\n"; break;
        case 4: std::cout << pstr << pstar4 << ".\n"; break;
        case 5: std::cout << pstr << pstar5 << ".\n"; break;
        case 6: std::cout << pstr << pstar6 << ".\n"; break;
        case 7: std::cout << pstr << pstar7 << ".\n"; break;
        case 8: std::cout << pstr << pstar8 << ".\n"; break;
        default: std::cout << "Sorry, you haven't got a lucky star." << std::endl;
    }
}
```

在该示例程序，我们使用了 $8$ 个相同类型的变量(`pstar1` 到 `pstar8`) 来存储明星的名字。如果使用数组来存储这些字符串，就需要定义一个二维数组，并指定每个字符串的最大长度，这样会浪费很多内存空间。使用指针变量来存储字符串字面值的地址，可以节省内存空间，并且代码更加简洁。

```cpp title="pointer_array_lucky_star.cpp"
#include <iostream>

int main()
{
    // 声明一个数组 pstars，其元素类型是 `const char *`
    const char* pstars[] {
        "Fatty Arbuckle",
        "Clara Bow",
        "Lassie",
        "Slim Pickens",
        "Boris karloff",
        "Mae West",
        "Oliver Hardy",
        "Greta Garbo"
        };

    std::cout << "Pick a lucky star! Enter a number between 1 and " << std::size(pstars) << ": ";
    size_t choice{};
    std::cin >> choice;

    if (choice >= 1 && choice < std::size(pstars))
    {
        std::cout << "Your lucky star is " << pstars[choice - 1] << ".\n";
    }
    else
    {
        std::cout << "Sorry, you haven't got a lucky star." << std::endl;
    }
    return 0;
}
```

这种用于存储指针的数组称为 **指针数组**。在上述例子中，`pstars` 是一个指针数组，其元素类型是 `const char*`。每个元素都存储了一个字符串字面值首字符的地址。通过这种方式，我们可以方便地管理多个字符串，并且节省内存空间。如下下图所示

![1763907514917-e291b1dc1a62c4928736acd44dfdeea8.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1763907514917-e291b1dc1a62c4928736acd44dfdeea8.png)

## 常量指针和指向常量的指针

在上述例子中，通过 `const char *` 声明的数组，确保任何试图修改 `pstars` 数组元素指向的字符串的行为都会被编译器阻止：

```cpp
const char *pstars[] {
    "Fatty Arbuckle",
    "Clara Bow",
    "Lassie",
    "Slim Pickens",
    "Boris karloff",
    "Mae West",
    "Oliver Hardy",
    "Greta Garbo"
};
```

在这个声明中，把由 `pstars` 数组的元素指向的 `char` 元素指定为常量。由于编译器会阻止对该对象的直接修改，因此下面的语句会标识为错误，防止在运行时期间出现问题

```cpp
*pstars[0] = 'X';  // 错误：试图修改常量数据
```

但是，可以合法的编写下面语句，把存储在等号右边的元素中的地址复制到等号左边的元素中

```cpp
pstars[5] = pstars[6];  // 合法：修改指针，使其指向不同的地址
```

现在，这些 `pstars[5]` 和 `pstars[6]` 都指向 `"Oliver Hardy"` 字符串字面值。原本的 `pstars[5]` 指向的 `"Mae West"` 字符串字面值仍然存在于内存中并且没有发生变化，但不再有指针指向它。因此，这没有违背 `const char *` 的约束。

如果希望指针本身也是常量，可以使用如下声明语句

```cpp
const char * const pstars[]{
    "Fatty Arbuckle",
    "Clara Bow",
    "Lassie",
    "Slim Pickens",
    "Boris karloff",
    "Mae West",
    "Oliver Hardy",
    "Greta Garbo"
}
```

额外的 `const` 关键字和后面的元素类型规范把元素定义为常量，现在指针及其指向的字符串都被定义为常量。这样，这个数组现在不能修改

上面的声明是通过数组来介绍的，这可能有一点复杂，难以理解。现在，我们使用一个基本类型的非数组变量再次回顾 **指向常量的指针** 和 **常量指针** 的概念。例如

```cpp
const char * star {"Lassie"};  // 指向常量的指针
```

这里定义了一个包含 `const char` 元素的数组，意味着编译器不允许将 `"Lassie"` 字符串字面值中的任何字符修改为其他字符

```cpp
star[1] = 'o';  // 错误：试图修改常量数据
```

但是，`star` 的定义并不阻止将 `star` 指向其他字符串字面值。这是因为 `star` 变量本身不是常量。换句话说，只要使用一个指向 `const char` 元素的指针，就可以修改 `star` 变量的值

```cpp
star = "Mae West";  // 合法：修改指针，使其指向不同的地址
star = pstars[1];  // 合法：修改指针，使其指向不同的地址
```

如果想禁止这种赋值，需要再添加一个 `const` 关键字来保护 `star` 变量本身

```cpp
const char * const star {"Lassie"};  // 指向常量的常量指针
```

::: tip

总结一下，对指针及其指向的内容使用 `const` 有一下三种情况

---

**指向常量的指针**：指针指向的内容是常量，即不能通过指针修改其指向的内容。但是，**可以修改指针，指向其他的常量**

```cpp
const char *pstring {"Some text that cannot be changed."};  // 指向常量的指针
```

当然，这也适用于其他类型的指针

```cpp
const int value {20};
const int *pvalue {&value};
```

`value` 是一个常量，不能修改。`pvalue` 是一个指向常量的指针，可以用于存储 `value` 的地址。不能在非 `const int` 指针中存储 `value` 的地址。但是，可以把非 `const` 变量的地址赋值给 `pvalue`。换句话说，**可以加强常量的不变性，但是不能减弱它**

---

**常量指针**：存储在指针中的地址不能改变，即指针本身是常量。但是，**可以通过指针修改其指向的内容**

```cpp
int data[20];
int *const pdata {&data};  // 常量指针
```

这条语句声明 `pdata` 是常量指针，指向 `data`。使它指向另一个变量的任何尝试都是错误的。但是，可以通过 `pdata` 修改 `data` 数组中的内容

```cpp
*pdata = 25;  // 允许的：指针指向的内容不是常量
```

如果将 `data` 声明为常量，就不能用 `&data` 初始化 `pdata`，指针 `pdata` 只能指向 `int` 类型的非 `const` 变量

---

**指向常量的常量指针**：因为存储在指针中的地址和指针指向的内容都可以被声明为常量，所以两者都不能修改。例如

```cpp
const float value {3.14f};
```

现在，`value` 是一个常量，不能修改。但仍然可以用 `value` 的地址来初始化一个指针

```cpp
const float * const pvalue {&value};  // 指向常量的常量指针
```

`pvalue` 现在是一个指向常量的常量指针，既不能修改 `pvalue` 指向的地址，也不能通过 `pvalue` 修改其指向的内容

:::

## 指针和数组

指针和数组之间有着密切的关系。实际上，在许多情况下，**可以把数组名用作指针**。在输出语句中，数组名本身可以像指针那样操作。如果在输出数组时只使用数组名，就会得到数组在内存中的十六进制地址，`char` 类型的数组例外，因为所有的标准输出流都假定它是 C 风格字符串。因为数组名可以解释为地址，所以它可以用于初始化指针

```cpp
double values[10] {};
double *pvalue {values};  // 这里涉及了隐式类型转换。
```

上述第二条语句把数组 `values` 的地址存储在指针 `pvalue` 中。**尽管数组名表示一个地址，但是数组名不是指针**。存储在指针中的地址可以修改，然而数组名表示的地址是固定的。因此，**可以将数组名理解为 `const T * const` 类型的指针**

::: tip

请注意：数组的长度是数组类型的一部分。也就是说，在上述语句中的 `values` 的类型是 `double[10]`。如果对 `values` 取地址，那么 `&values` 的类型是 `double (*)[10]`。

:::

然而，编译器将数组名当做指针来处理时，其值是数组中第一个元素的地址。也就是说，上述语句中的 `values` 编译器解释为指针时，其类型是 `double *`。至于 C++ 这样处理的原因是为了支持指针的算术运算

### 指针的算术运算

C++ 允许对指针进行算术运算，修改它存储的地址。注意，只能对指针进行加减运算，还可以对指针进行比较运算。可以给指针加上一个整数（或者整数类型的表达式），其结果是一个地址。也可以从指针中减去一个整数（或者整数类型的表达式），其结果也是一个地址。还可以从一个指针中减去另一个指针，其结果是一个整数而不是地址。

对指针的算术运算采用一种特殊的方式。假定使用下面的语句给指针加 $1$

```cpp
++pvalue;
```

这条语句将指针递增 $1$。也可以采用 `+=` 运算符

```cpp
pvalue += 1;
```

存储在指针中的地址并不是按照一般的算术运算那样递增 $1$。假定指针指向的是数组中的一个元素，给指针加 $1$ 就表示给它递增一个所指向类型的元素。编译器知道存储一个数组元素需要的字节数，给指针加 $1$ 就是给指针中存储的地址递增该字节数。换言之，**给指针加 $1$ 就是把指针移向数组中的下一个元素**。例如，

![1764000746785-2dd5ae528e2190f15245323864579551.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1764000746785-2dd5ae528e2190f15245323864579551.png)

`pvalue` 开始存储的地址对应于数组的第一个元素。给 `pvalue` 加 $1$ 就是对它包含的地址递增 $8$，结果就是下一个元素的地址。给指针递增 $2$，就是把指针移动两个元素。当然，指针 `pvalue` 不一定指向数组的第一个元素。例如

```cpp
pvalue = &values[2];  // 指向数组的第三个元素
```

现在，`pvalue + 1` 就等于 `values[3]` 的地址，`values[3]` 是数组中的第 $4$ 哥元素。下面的语句可以使指针指向这个元素

```cpp
pvalues += 1; // 现在指向 values[3]
```

::: tip

一般情况下，表达式 `pvalue + n`(其中 `n` 是整数类型的表达式)的结果是包含在指针 `pvalue` 中的地址加上 `n * sizeof(double)`，因为 `pvalue` 被声明为指向 `double` 类型的指针。

:::

相同的逻辑，也可以从指针中减去一个整数。如果 `pvalue` 指向 `values[2]`，则表达式 `pvalue - 2` 就等于数组中的第一个元素 `values[0]` 的地址。换言之，**递增或递减指针的操作将根据指针所指向对象的类型来执行**

当然，可以对执行了算术运算的指针进行解引用，否则对指针执行算术运算也没有意义。例如，假定 `pvalue` 指向 `values[3]`，则下面的语句

```cpp
*(pvalue + 1) = *(pvalue + 2);
```

等价于

```cpp
values[4] = values[5];
```

`pvalue + 1` 这样的表达式并不会改变 `pvalue` 中的地址，这个表达式的结果与 `pvalue` 的类型相同。而 `++pvalue` 和 `pvalue += n` 表达式会改变 `pvalue` 中存储的地址。

在递增或递减指针包含的地址后，要解除对指针的引用，就需要使用圆括号，因为间接运算符的优先级高于算术运算符 `+` 和 `-`。表达式 `*pvalue + 1` 对 `pvalue` 指向的地址中存储的值加 $1$，也就是 `values[3] + 1`

---

C++ 允许从一个指针中减去另一个指针，但这 **仅在指针的类型相同且指向同一个数组中的元素** 时才有意义。假设有一个一维数组 `numbers`，其元素类型是 `long`，定义语句如下

```cpp
long numbers[] {10, 20, 30, 40, 50, 60, 70, 80};
```

定义并初始化两个指针变量

```cpp
long *pnum1 {&numbers[6]}; // 指向 numbers[6]
long *pnum2 {&numbers[1]}; // 指向 numbers[1]
```

现在计算两个指针之间的差

```cpp
auto difference {pnum1 - pnum2};  // 结果为 5
```

变量 `difference` 被设置为整数 $5$，因为指针之差有元素决定，而不是由字节决定。但是，`difference` 的类型是什么？显然，应该是有符号整数，以便于能够处理如下语句

```cpp
auto difference {pnum2 - pnum1};  // 结果为 -5
```

指针变量的大小由平台决定，通常是 $4$ 或者 $8$ 字节。这当然意味着，存储指针偏移所需要的字节数并非在所有平台上都相同。因此，C++ 规定将两个指针相减，得到的值的类型为 `std::ptrdiff_t`，这是在 `<cstddef>` 模块中定义的某个带符号整型的平台特定的类型名

```cpp
std::ptrdiff_t difference {pnum2 - pnum1};  // 结果为 -5
```

取决于目标平台，可能是 `int` 类型，也可能是 `long` 类型，甚至可能是 `long long` 类型。

---

C++ 还允许指针之间进行比较。C++ 中的比较运算符 `>`、`<`、`>=`、`<=`、`==` 和 `!=` 都可以用于指针。指针比较的结果是布尔值 `true` 或 `false`。但是，**只能比较指向同一个数组中元素的指针**。使用之前相同的变量，表达式 `pnum2 < pnum1` 的结果为 `true`，因为 `pnum2 -pnum1 < 0 (pnum2 - pnum1 = -5)`。 换句话说，如果指针指向数组的位置更深，或者元素的索引越大，指针就更大

### 使用数组名的指针表示

可以把数组名当做指针来确定数组元素的地址。如果把一维数组定义为

```cpp
long data[5] {};
```

就可以使用指针表示法把元素 `data[3]` 表示为 `*(data + 3)`。这种表示法可以应用于一般情形，如元素 `data[0]` `data[1]` 等，可以分别表示为 `*(data + 0)`、`*(data + 1)` 等。数组名 `data` 本身表示数组开始时的地址，而表达式 `data + 2` 就表示和起始位置偏离两个元素的地址

数组名的指针表示法与方括号中索引的使用方式相同。下面的循环把 `data` 数组的值设置为偶数

```cpp
for (size_t i{}; i < std::size(data); ++i)
{
    *(data + i) = 2 * (i + 1);
}
```

表达式 `*(data + i)` 表示数组中连续的元素。上述循环把 $5$ 个数组元素的值分别设置为 $2, 4, 6, 8, 10$。使用下面的语句可以累加数组元素的值

```cpp
long sum {};

for (size_t i {}; i < std::size(data); ++i)
{
    sum += *(data + i);
}
```

下面在一个有更多实际内容的例子中使用这种表示法。这个例子计算素数

```cpp title="prime.cpp"
#include <iostream>
#include <format>

int main()
{
    constexpr size_t size{ 100 };  // 素数的个数
    long primes[size]{ 2 };  // 2 是已知的素数

    size_t count{ 1 }; // 统计素数的个数
    long trial{ 3 }; // 下一个要测试的数

    while (count < size)
    {
        bool isprime{ true };  // 表示 trial 是否为素数。首先，假设它是素数
        // 遍历素数表: trial % primes[i] == 0 则不是素数，结束循环。
        for (size_t i{}; i < count && isprime; ++i)
        {
            // 合数一定可以被比它更小的素数整除
            isprime = trial % *(primes + i) > 0;  // 如果能整除，说明不是素数
        }
        // 检查 isprime 的值
        if (isprime)
        {
            *(primes + count++) = trial;  // 记录下这个素数
            // count++ 的值是更新前的 count
        }
        trial += 2;  // 只测试奇数
    }
    // 输出素数表。每行输出 10 个
    std::cout << std::format("The first {} primes are: \n", size);
    for (size_t i{}; i < size; ++i)
    {
        std::cout << std::format("{:7}", *(primes + i));

        // 已经输出 10 个元素换行
        if ((i + 1) % 10 == 0)
        {
            std::cout << std::endl;
        }
    }
    std::cout << std::endl;
}
```

## 动态内存分配

前面编写的大部分代码都是在编译期间给数据分配内存空间。但是，使用 `std::vector<>` 容器时是例外，它动态分配自己需要的内存来保存元素。除此之外，我们主要在源代码中指定需要的变量和数组，在执行程序时，这些内存空间已经分配好了，不管是否需要整个数组。程序中使用固定的变量集合是非常受限制的，而且常常比较浪费

动态内存分配是在运行期间分配存储数据所需要的内存空间，而不是在编译程序时分配预定义的内存空间。在执行过程中可以改变程序所有的内存量。根据定义，动态分配内存的变量不能在编译期间定义，所以它们不能再源程序中指定。

在动态分配内存时，请求分配的空间由其地址标识。存储这个地址的唯一地方显然是指针。利用指针的功能和 C++ 的动态内存管理工具，编写具有这种灵活性的程序就非常便捷了。可以在需要时给应用程序添加内存，使用完毕后释放获得的内存，因此应用程序使用的内存量可以在执行期间增加或减少

在 [第三章 处理基本数据类型#变量的生存期和作用域](./003-处理基本数据类型.md#变量的生存期和作用域) 中介绍了变量可以拥有三种存储持续时间：**自动**、**静态** 和 **动态**，并且讨论了如何创建自动变量和静态变量。在运行期间分配内存的变量始终具有动态的存储持续时间。

### 栈区和自由存储区

自动变量在执行其定义时创建。在内存区域给自动变量分配的空间称为 **栈(stack)**。栈大小固定，由编译器决定。编译器通常允许改变栈的大小，但很少需要这么做。在定义自动变量的代码块尾，会自动释放栈上的变量所占据的内存，以供重复使用。调用函数时，传递给函数的参数和地址就存储在栈上，函数执行完毕后，就返回该地址

操作系统或当前加载的其他程序未占用的内存称为 **自由存储区**，或者 **堆区**。在运行期间，可以把自由存储区中的空间分配给任意类型的新变量。需要使用 `new` 运算符，它返回分配空内存空间的首地址，把改地址存储在一个指针中。和它对应的运算符 `delete` 用于释放之前用 `new` 分配的内存。`new` 和 `delete` 都是关键字，不能用于其他目的。

在正式介绍这两个关键字之前，我们先来看一下 C++ 程序的虚拟内存布局

::: tip

操作系统采用 **虚拟内存** 技术提供了 **进程独占所有物理内存** 的假象。在进程中看见的地址都是虚拟内存地址。下图展示了在 Linux x86-32 平台上的进程的虚拟内存布局。不同平台的布局可能有所不同，但大致结构是类似的。

![1764115975289-716754a653c92e7d076c241f7854db33.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1764115975289-716754a653c92e7d076c241f7854db33.png)

从这个图上可以看出地址为 `0x00000000` 的内存是没有被使用的。接下来的内存区域是 **代码段**，存储程序的 **机器码指令** 和 **立即数**(可以将立即数理解为字面值)。在代码段后面的区域称为 **数据区域**，数据区域被分成了两部分：**初始化数据段** 和 **未初始化数据段**。初始化数据段存储已经初始化的静态变量和全局变量，未初始化数据段存储未初始化的静态变量和全局变量。

接下来的内存区域是 **堆区（也称自由存储区）**，用于动态分配内存。堆区的大小可以动态改变。堆区之后是一大部分的未分配内存，这部分内存用于堆区和栈区的增长。接下来的内存区域是 **栈区**，用于存储自动变量和函数调用信息。栈区的大小通常是固定的。在栈区的顶部是未使用的内存区域

虚拟内存的最高地址通常是保留给操作系统使用的，这部分内存是无法被访问的

:::

### 运算符 new 和 delete

假定一个 `double` 类型的变量需要内存空间。可以定义一个`double *` 类型的指针，在执行程序时，请求为该 `double` 类型变量分配内存空间，并把分配的内存地址存储在指针中。下面的语句完成了这些任务

```cpp
double *pvalue {nullptr};
pvalue = new double;  // 使用 new 运算符分配内存
```

注意，所有指针都应该初始化。使用动态分配的内存一般涉及许多浮动的指针，这些指针不应该包含垃圾值，这是非常重要的。如果指针没有包含合法的地址，就应该让他总是包含 `nullptr`。在上面的例子中，首先把指针 `pvalue` 初始化为 `nullptr`，然后使用 `new` 运算符分配内存，并把分配的内存地址赋值给 `pvalue`。这样就可以通过前面介绍的间接运算符，使用这个指针引用该变量了

```cpp
*pvalue = 3.14;
```

当然，在极端情况下，由于自由存储区的内存空间已经用尽，内存分配就不可行。另外，自由存储区还有可能因以前使用过而被分隔成 **小碎块**，此时自由存储区就 **不能提供足够大的连续空间** 来容纳要获得内存空间的变量了。存储一个 `double` 值不需要很大的空间，但是在处理非常大的实体，例如数组或者复杂对象时，就需要很大的空间。显然，应该考虑这种情况，但现在仅假定我们总是能得到需要的内存空间。在 [第十六章 运行时错误和异常](./016-运行时错误和异常.md) 中介绍如何处理内存分配失败的情况

请注意，语句

```cpp
pvalue = new double;  // 使用 new 运算符分配内存
```

是没有初始化分配的内存的。如果希望初始化分配的内存，可以使用下面的语句

```cpp
pvalue = new double{3.14};  // 使用 new 运算符分配并初始化内存
```

C++ 允许在声明指针的时候，就可以使用 `new` 运算符返回的地址初始化指针。例如

```cpp
double *pvalue {new double{3.14}};  // 声明并初始化指针
```

使用 `new` 运算符分配的内存不会自动释放。必须使用 `delete` 运算符来释放之前分配的内存。例如，下面的语句释放了之前分配给 `pvalue` 的内存

```cpp
delete pvalue;  // 释放之前分配的内存
pvalue = nullptr; // 避免悬空指针 // [!code highlight]
```

::: warning

释放内存后，指针 `pvalue` 仍然包含之前分配的内存地址。这时，`pvalue` 就成为了一个 **悬空指针**，因为它指向的内存已经不再属于程序。如果不把 `pvalue` 设置为 `nullptr`，就有可能在后续代码中错误地使用该指针，从而导致未定义行为。因此，释放内存后，应该立即将指针设置为 `nullptr`，以避免悬空指针的问题。

:::

### 数组的动态内存分配

在运行期间为数组动态分配内存是很简单的。例如，下面的语句为包含 $100$ 个 `double` 类型值的数组分配内存空间，并把它的地址存储在 `data` 指针中

```cpp
double *data {new double[100]}; // 为包含 100 个 double 类型值的数组分配内存
```

这个数组的内存包含了未初始化的垃圾值。可以像初始化普通数组那样，初始化数组的元素

```cpp
double *data {new double[100]{}}; // 为包含 100 个 double 类型值的数组分配并并将每个元素初始化为 0.0
double *data {new double[100]{1.0, 2.0, 3.0}}; // 为包含 100 个 double 类型值的数组分配并将前 3 个元素初始化为 1.0、2.0 和 3.0，其余元素初始化为 0.0
```

::: warning

请注意：`data` 只是一个 `double` 类型的指针。这是与普通数组不同的一点。我们无法让编译器通过给定的初始化列表推断数组的长度。

这个限制在 C++20 标准之后得到了解决。C++20 标准支持让编译器通过初始化列表推断动态分配数组的长度。例如

```cpp
double *data {new double[]{1.0, 2.0, 3.0}}; // C++20 标准之后支持
```

上述语句只有在 C++20 标准之后才能通过编译。在此之前的标准中，必须显式指定数组的维数。

:::

数组使用完成之后，要从自由存储区中删除，此时需要使用 `delete[]` 运算符。

```cpp
delete[] data;  // 释放之前分配的数组内存
data = nullptr; // 避免悬空指针
```

::: danger

请注意：`delete[]` 后面的方括号非常重要，在释放数组占用的自由存储内存时必须使用它。否则，结果是不可预料的。还要注意的是，`delete[]` 不需要指定数组的长度。

:::

下面我们使用动态分配的数组重新实现 `prime.cpp` 程序

```cpp title="prime2.cpp"
#include <iostream>
#include <format>

int main()
{
    size_t size{ };  // 素数的个数
    std::cout << "How many primes would you like to calculate? ";
    std::cin >> size;

    long* primes{ new long[size] {2} }; // 动态分配一个数组来保存素数
    size_t count{ 1 }; // 统计素数的个数
    long trial{ 3 }; // 下一个要测试的数

    while (count < size)
    {
        bool isprime{ true };  // 表示 trial 是否为素数。首先，假设它是素数
        // 遍历素数表: trial % primes[i] == 0 则不是素数，结束循环。
        for (size_t i{}; i < count && isprime; ++i)
        {
            // 合数一定可以被比它更小的素数整除
            isprime = trial % *(primes + i) > 0;  // 如果能整除，说明不是素数
        }
        // 检查 isprime 的值
        if (isprime)
        {
            *(primes + count++) = trial;  // 记录下这个素数
            // count++ 的值是更新前的 count
        }
        trial += 2;  // 只测试奇数
    }
    // 输出素数表。每行输出 10 个
    std::cout << std::format("The first {} primes are: \n", size);
    for (size_t i{}; i < size; ++i)
    {
        std::cout << std::format("{:7}", *(primes + i));

        // 已经输出 10 个元素换行
        if ((i + 1) % 10 == 0)
        {
            std::cout << std::endl;
        }
    }
    std::cout << std::endl;
    delete[] primes;  // 释放动态分配的内存
    primes = nullptr;
    return 0;
}
```

#### 多维数组

在[第五章 数组和循环#多维数组](./005-数组和循环.md#多维数组) 中介绍了如何创建和使用多维数组。当时使用了一个三行四列的多维数组，用来保存菜园中的胡萝卜的重量

```cpp
double carrots[3][4] {};
```

当然，园丁每年都种胡萝卜，但不一定每年都种相同的数量，或者一直采用三行四列的形式。每年在种下胡萝卜后都重新编译源代码是很枯燥的工作，所以我们来看看如何动态分配多维数组。

惯性思维就是像声明普通多维数组那样使用 `new` 运算符进行分配

```cpp
size_t rows{ 3 };
size_t cols{ 4 };

auto carrots { new double[rows][cols]{} }; // 错误：不能这样分配多维数组 // [!code focus]
```

但是，**C++ 标准不支持有多个动态维数的多维数组**，至少没有将其作为一种内置的语言特性提供支持。换句话说，使用内置的 C++ 类型，最多让第一个维度的值是动态的。如果 `cols` 是一个固定值，假设为 $4$，那么可以如下声明一个多维数组

```cpp
size_t rows{ 3 };

double (*carrots)[4] { new double[rows][4]{} }; // 动态分配一个三行四列的二维数组
```

::: tip

我们知道数组名是指向数组中第一个元素的指针。因此，多维数组名当做指针时，指向多维数组中第一个数组的指针。

对于二维数组声明语句 `double carrots[3][4]` 而言，`carrots` 的类型是 `double[3][4]`。然而，编译器将数组名当做指针使用时，其值是指向第一个元素的指针。对于 `carrots` 而言，其第一个元素是一个包含 $4$ 个 `double` 元素的数组，类型是 `double[4]`，该类型的指针类型是 `double (*)[4]`。因此，当数组名 `carrots` 被当做指针使用时，编译器将其类型视为 `double (*)[4]`

:::

`double (*)[4]` 这种类型显得比较复杂，但是从 C++11 标准开始，可以使用 `auto` 关键字来让编译器自动推断类型，从而简化变量的声明

```cpp
size_t rows{ 3 };

auto carrots {new double[rows][4]{} }; // 合法：只有第一个维度是动态的
```

我们知道，C++ 中的多维数组是按照 **行主序** 存储的，意味着数组的每一行是连续存储的。因此，我们完全可以把二维数组看当做一维数组使用。如下所示

```cpp
size_t rows{ 3 };
size_t cols{ 4 };

auto carrots { new double[rows * cols]{} }; // 动态分配一个包含 12 个 double 元素的一维数组
// 访问元素 carrots[i][j] 可以通过 carrots[i * cols + j] 实现

carrots[1 * cols + 2] = 5.5; // 访问 carrots[1][2]
```

此外，还可以使用 **指针数组** 模拟二维数组。就是使用一个数组存储指针，指针指向另一个数组的第一个元素。例如

```cpp
double **carrots {new double*[rows]{}};  // 分配一个长度为 rows 的指针数组

for (size_t i{}; i < rows; ++i)
{
    carrots[i] = new double[cols]{};  // 为每一行分配一个长度为 cols 的数组
}

// 释放每一行
for (size_t i{}; i < rows; ++i)
{
    delete[] carrots[i];  // 释放每一行的数组
}
delete[] carrots;  // 释放指针数组
carrots = nullptr;
```

`carrots` 是一个指向指针的指针，`carrots` 中的每个元素都是一个指向 `double` 类型数组的指针。通过这种方式，可以动态分配多维数组，并且每一行的长度可以不同。

## 通过指针选择成员

指针不仅可以指向基本类型的数据，还可以指向复杂类型的数据，例如结构体和类的对象。当指针指向结构体或类的对象时，可以使用箭头运算符 `->` 来访问该对象的成员。箭头运算符是间接运算符 `*` 和成员访问运算符 `.` 的组合。例如，`std::vector<T>` 容器的 `at()` 成员函数可以访问元素，`push_back()` 成员函数可以向容器添加元素。假定 `pdata` 是一个 `vector<>` 容器的指针。例如

```cpp
auto* pdata {new std::vector<int>{}};
```

也可以使用地址运算符获取局部对象的地址

```cpp
std::vector<int> data{};
auto* pdata {&data};
```

这两种情况，编译器都可以正确推断 `pdata` 的类型是 `std::vector<int>*`，即指向 `int` 元素类型的 `vector<>` 容器的指针。

对于接下来的内容，不需要区分是在栈区创建的对象还是在自由存储区创建的对象。要添加元素，需要调用 `vector<int>` 容器的 `push_back()` 成员函数。前面介绍过，需要使用表示 `vector<>` 对象的变量和成员函数名之间的句点。因此，要使用指针就必须解引用获得 `vector<>` 对象，所以

```cpp
(*pdata).push_back(10);  // 通过指针添加元素
```

包围在 `*pdata` 周围的圆括号是必须的，因为运算符解引用运算符 `*` 的优先级比成员访问运算符 `.` 的优先级低。这种方式虽然可以工作，但并不直观。更好的方法是使用箭头运算符 `->`，它结合了解引用运算符和成员访问运算符。例如

```cpp
pdata->push_back(10);  // 通过指针添加元素
```

## 动态内存分配的危险

在使用 `new` 运算符分配内存时，可能出现许多严重的问题。下面我们将列出一系列问题

### 悬挂指针或多次释放

**悬挂指针** 是这样的一个指针变量：在使用 `delete` 和 `detele[]` 运算符释放内存之后，指针变量仍然包含自由存储区中的地址

+ 解引用悬挂指针会读取或写入已分配给程序其他部分使用的内存，导致各种无法预料的结果
+ 当使用 `delete` 或 `delete[]` 对已经释放的指针（已经成为悬挂指针）再次进行释放时，会发生多次释放，导致另一种灾难性结果

防范悬挂指针的基本策略就是：在释放指针指向的内存之后，立即将指针变量重置为 `nullptr`。然而，这样的策略存在缺陷。在更复杂的程序中，代码的不同部分通过访问相同的内存（一个对象或者对象数组）来进行协作，这是通过相同指针的不同副本实现的。此时，代码何时、在何处调用 `delete` 或 `delete[]` 运算符并不明显。换句话说，**如何确保没有其他代码仍然在使用相同的动态内存？**

### 分配与释放的不匹配

使用 `new[]` 动态分配的数组保存在一个普通的指针变量中，而使用 `new` 动态分配的内存的单个值也是如此

```cpp
int *pinteger {new int{42}};      // 分配单个 int
int *parray {new int[10]{}};      // 分配包含 10 个 int 的数组
```

此后，编译器无法区分这两个指针指向的内容，当指针在程序的不同部分传递时更是如此。这意味着下面的两条语句可通过编译，编译器不会报错(很多情况下甚至不会发出警告)

```cpp
delete[] pinteger;  // 错误：pinteger 指向单个 int
delete parray;     // 错误：parray 指向一个 int 数组
```

当分配和释放使用的运算符不能匹配时，会发生什么完全取决于编译器的具体实现。但可以肯定的是，结果不会很好

::: warning

每个 `new` 必须对应一个 `delete`，每个 `new[]` 必须对应一个 `delete[]`。如果不能这样对应，就会导致不确定的行为或 **内存泄漏**

:::

### 内存泄漏

在使用 `new` 或 `new[]` 分配内存空间时，使用完内存没有释放，就会出现内存泄漏。例如，如果因为改写了指针中保存的地址，而丢失已分配的自由存储区内存地址，就会出现内存泄漏。这一般在循环中发生，而且比我们想象的更容易出现这类问题。结果是程序在 **自由存储区中消耗的内存空间越来越多**，使程序越来越慢，甚至可能在分配自由存储区中的所有空间之后，再次请求分配内存时失败

谈到作用域，指针和其他变量一样的。指针变量的作用域从代码块中定义它的地方开始，到该代码块结束为止。在该代码块之后，该指针就不存在了，因此它包含的地址也不能访问了。**如果指针包含自由存储区域中的某个内存块的地址，在该指针超出作用域时，就不能释放该内存块了**。

很容易看出，在所分配的内存附近的代码中，该内存在某个地方不再使用，但忘记使用 `delete` 释放内存了。程序员常犯下这样的错误，甚至是在分配和释放变量之间使用 `return` 语句。在复杂的程序中更难找出内存泄漏，因为内存可能是在程序的某个部分分配，却应该在另一个完全不同的部分释放

避免内存泄漏的基本准则：**在每次使用 `new` 运算符时，立即在某个适当的位置添加 `delete` 运算符**。但这种策略并不能完全保证不出问题。特别强调：**所有人是会犯错误的**。所以，当直接操作动态内存时，程序员迟早会引入内存泄漏。即使在编写代码的时候，程序可以工作，很多时候随着程序的不断演化，也会开始出现bug。例如，添加了 `return` 语句，条件测试发生了变化，抛出异常，等等。突然之间，在一些场景中，内存得不到正确释放

### 自由存储区的碎片

内存碎片化在频繁分配和释放内存块的程序中会出现。每次使用 `new` 运算符时，都会分配连续的字节块。如果创建并释放许多大小不同的内存块，所分配的内存就可能散布在小的自由内存块中，每个小的内存块都不足以容纳程序新的内存请求。**自由内存的总量可能非常大，但如果每个内存块都相当小，不能满足当前要求，内存分配请求就会失败**。下图演示了内存碎片化的效果

![1764254233135-6cb96666a80425e790126a180c393f9e.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1764254233135-6cb96666a80425e790126a180c393f9e.png)

## 智能指针

::: danger

虽然我们花了大量的篇幅来介绍内存分配。但是，在现代 C++ 程序设计规范，**不要直接使用 `new/delete` 和 `new[]/delete[]`**。

我们应该总是使用 `std::vector<>` 容器来替换动态分配的数组(包括普通数组)。使用 **智能指针（动态分配内存并管理其生存期限）** 替换 **裸指针** 操作。这些高级替代方法可以有效降低内存泄漏的危险

:::

我们前面介绍的所有指针类型都是 C++ 语言的一部分。这些称为 **原始指针（裸指针）**，因为这些类型的变量只能存储地址。原始指针可以存储自动变量或者在自由存储区中分配的变量的地址。

智能指针是模拟原始指针行为的对象，因为它包含一个地址，在许多方面使用与原始指针相同的方式使用它。智能指针仅用于存储在自由存储区中分配的内存地址。智能指针做的工作比原始指针多得多。**智能指针最著名的特性就是不必使用 `delete` 或 `delete[]` 来释放内存，只要不需要智能指针，它们就会自动释放内存**。这样避免了多次释放、分配/释放不匹配和内存泄漏问题。当然，使用智能指针，悬挂指针的情况也不会存在。

::: tip

智能指针非常重要，它特别适合管理动态创建的对象。在后续会经常使用智能指针

:::

智能指针类型由标准库的 `<memory>` 模块中的模板定义，所以必须导入 `<memory>` 模块才能使用智能指针类型。C++ 标准库中提供了三种智能指针类型：`std::unique_ptr<T>`、`std::shared_ptr<T>` 和 `std::weak_ptr<T>`，它们 **类似于指向 `T` 类型的指针**。下面的表格简要介绍了这三种智能指针类型

|智能指针类型|描述|
|:----------|:---|
|`std::unique_ptr<T>`|每个 `unique_ptr<>` 对象独占一个地址，不允许多个 `unique_ptr<>` 对象共享同一个地址。|
|`std::shared_ptr<T>`|允许有任意个 `shared_ptr<T>` 对象共享同一个地址。内部维护引用计数，只有最后一个 `shared_ptr<T>` 被销毁时，才释放内存。|
|`std::weak_ptr<T>`|弱引用指针，用于解决 `std::shared_ptr<T>` 循环引用的问题|

::: tip

这简要描述就能感觉到 `weak_ptr<>` 的使用场景比较特殊。在后续内容中不会介绍 `weak_ptr<>` 的使用。如果需要了解 `weak_ptr<>`，可以参考相关资料

:::

### 使用 `unique_ptr<T>` 指针

`std::unique_ptr<T>` 对象唯一地存储了地址，所以它指向的值由 `std::unique_ptr<T>` 智能指针独占拥有。释放 `std::unique_ptr<T>` 对象时，它指向的值也会释放。`unique_ptr<>` 最适合用于动态分配对象。因此，**其指向的对象不应被程序的多个部分共享**，或者 **不应用于动态对象的生存期与程序中的其他某个对象捆绑在一起的情形**。`unique_ptr<>` 的一种常见用途是保存所谓的多态指针，实际上是指向动态分配对象的指针，允许动态分配的对象时任意数量的相关类型。关于多态性，我们会在 [第十二章 定义自己的数据类型](./012-定义自己的数据类型.md)、[第十三章 运算符重载](./013-运算符重载.md)、 [第十四章 继承](./014-继承.md) 和 [第十五章 多态性](./015-多态性.md) 中介绍。之后，就能完全理解这种智能指针的用途了

下面我们以基本类型的对象的动态分配为例介绍 `std::unique_ptr<T>` 的使用。虽然这并不非常有用。不过可以说明智能指针为什么要比裸指针安全

从 C++14 标准开始，要求使用模板函数 `std::make_unique<T>()` 来创建 `std::unique_ptr<T>` 对象。例如，下面的语句创建了一个指向 `double` 类型的值的 `unique_ptr<>` 对象

```cpp
std::unique_ptr<double> pvalue {std::make_unique<double>(3.14)};
// 创建一个指向 double 类型值的 unique_ptr 对象
```

`std::make_unique<T>(...)` 的参数就是使用 `new T{...}` 进行动态分配是在初始化列表中的值。在本例中，即 `double` 类型的字面值 $3.14$。当然，也可以使用 `auto` 关键字让编译器自动推断类型

```cpp
auto pvalue {std::make_unique<double>(3.14)};  // 使用 auto 关键字
```

::: tip

要创建一个 `std::unique_ptr<T>` 对象来指向新分配的 T 类型的内存，应该总是使用 `std::make_unique<T>()` 函数，而不是直接使用 `new` 运算符

如果使用的编译器不支持 C++14 标准，可以使用下面的语句创建 `std::unique_ptr<T>` 对象

```cpp
std::unique_ptr<double> pvalue {new double{3.14}}; // 不推荐
```

这种方式虽然可以工作，但不推荐使用

:::

`pvalue` 的解引用操作与普通指针相同。例如，下面的语句修改 `pvalue` 指向内存中的值，并输出 `pvalue` 指向的值

```cpp
*pvalue = 999.0;
std::cout << *pvalue << std::endl;
```

如果想要获取 `std::unique_ptr<T>` 对象持有的内存地址，可以使用 `get()` 成员函数。例如

```cpp
std::cout << "Address: " << pvalue.get() << std::endl; // 输出 pvalue 持有的内存地址
```

::: tip

所有的智能指针都有一个成员函数 `get()`，它返回智能指针持有的内存地址。这个成员函数只能在一种情况下调用：当需要把智能指针传递给只接受原始指针参数的函数时，并且函数仅短时间使用该指针。

禁止将它传递给创建并长时间使用原始指针副本的函数或对象。如果原始指针和智能指针指向同一个对象，则不建议保留原始指针。否则，可能导致悬挂指针以及double free 等问题

:::

当然，也可以创建指向数组的 `std::unique_ptr<T[]>` 对象。例如，下面的语句创建了一个包含 $10$ 个 `double` 类型值的数组

```cpp
auto pvalues {std::make_unique<double[]>(10)}; // 创建一个包含 10 个 double 类型值的数组
```

`pvalues` 是指向自由存储中元素类型为 `double` 包含 $10$ 个元素的数组。与原始指针一样，可以使用数组表示法和智能指针来访问指向的数组元素

```cpp
for (size_t i {}; i < 10; ++i)
{
    pvalues[i] = static_cast<double>(i + 1);
}
```

使用 `static_cast<double>(i + 1)` 将 `size_t` 类型的值转换为 `double` 类型的值。默认情况下，编译器会发出隐式类型转换的警告

::: tip

对于数组而言，我们使用 `std::vector<T>` 容器来替换动态分配的数组(包括普通数组)。而不是使用 `std::unique_ptr<T[]>` 来管理动态分配的数组

此外 `std::make_unique<T[]>(n)` 创建 `T` 类型的变量且变量的值已初始化。通常是初始化为 `T` 类型的零值。然而，这种初始化并不是必须的，有时候可能会影响性能（清空内存会花大量时间）

:::

成员函数 `reset()` 可以重置 `unique_ptr<>` 中包含的指针或者任意类型的智能指针

```cpp
pvalue.reset(); // 重置 pvalue，现在指针是 nullptr
```

`pvalue` 仍存在，但不再指向任何内容。这是一个 `unique_ptr<double>` 对象，因为没有其他的唯一指针包含数组的地址，所以释放数组占用的内存。当然，通过显式地将智能指针与 `nullptr` 进行比较，可以检查智能指针是否包含 `nullptr`。此外，就像原始指针那样，智能指针还可以方便的转换为布尔值（即，当且仅当智能指针包含 `nullptr` 是，才转换为 `false`）

```cpp
if (pvalue)
{
    std::cout << "The first value is: " << pvalue[0] << std::endl;
}
```

`std::unique_ptr<T>` 类型的变量默认会使用 `nullptr` 进行初始化。也就是说

```cpp
std::unique_ptr<double> pvalue; // pvalue 默认初始化为 nullptr
```

总是可以通过 `reset()` 成员函数修改智能指针的值，否则创建空智能指针就没什么作用了

```cpp
pvalue.reset(new double{2.718}); // 修改 pvalue，使其指向一个新的 double 类型值
```

::: tip

换句话说，调用 `reset()` 成员函数时如果不指定参数，则相当于使用 `nullptr` 作为参数调用  `reset(nullptr)` 成员函数。

无论如何，智能指针之前指向的内存空间一定会被释放。
:::

除了 `get()` 和 `reset()` 成员函数之外，`std::unique_ptr<T>` 还有一个成语函数 `release()`，该函数将智能指针转换会原始指针。换句话说，该函数返回智能指针持有的地址，并且 **释放智能指针对该地址的控制权**。例如

```cpp
double* raw_ptr {pvalue.release()}; // 获取原始指针，并释放 pvalue 对该地址的控制权
```

由于智能指针不再管理该地止，程序员需要手动释放该内存，以避免内存泄漏。例如，可以使用 `delete` 运算符释放内存

```cpp
delete raw_ptr; // 释放内存
raw_ptr = nullptr; // 避免 悬空指针
```

## 使用 `shared_ptr<T>` 指针

定义 `std::shared_ptr<T>` 对象与定义 `std::unique_ptr<T>` 对象类似。但是，应该使用 `std::make_shared<T>()` 模板函数来创建 `std::shared_ptr<T>` 对象。例如，下面的语句创建了一个指向 `double` 类型值的 `shared_ptr<>` 对象

```cpp
std::shared_ptr<double> pvalue {std::make_shared<double>(3.14)};
```

我们可以像使用普通指针那样使用 `std::shared_ptr<T>` 对象。例如，下面的语句修改 `pvalue` 指向内存中的值，并输出 `pvalue` 指向的值

```cpp
*pvalue = 999.0;
std::cout << *pvalue << std::endl;
```

还可以赋值给其他 `std::shared_ptr<T>` 对象，从而实现多个智能指针共享同一个地址。例如

```cpp
std::shared_ptr<double> pvalue2 {pvalue}; // 初始化：引用计数增加 1

std::shared_ptr<double> pvalue3;
pvalue3 = pvalue; // 赋值：引用计数增加 1
```

::: tip

`std::shared_ptr<T>` 对象内部维护了一个引用计数器，记录有多少个 `std::shared_ptr<T>` 对象共享同一个地址。

当使用这个 `shared_ptr<T>` 对象初始化另一个 `shared_ptr<T>` 对象时，引用计数器会增加 $1$。

当使用赋值运算符将一个 `std::shared_ptr<T>` 对象赋值给另一个 `std::shared_ptr<T>` 对象时，引用计数器也会增加 $1$。

当一个 `std::shared_ptr<T>` 对象被销毁时，引用计数器会减少 $1$。只有当最后一个 `std::shared_ptr<T>` 对象被销毁时，才会释放内存

:::

`std::shared_ptr<T>` 类型与 `std::unique_ptr<T>` 类型的唯一不同就是 `std::unique_ptr<T>` 是独占一个地址的，不允许拷贝(初始化或赋值)。然而，`std::shared_ptr<T>` 允许多个智能指针共享同一个地址。

从 C++20 标准开始，`std::shared_ptr<T>` 也支持 `std::make_shared<T[]>(n)` 来创建动态分配的数组。例如，下面的语句创建了一个包含 $10$ 个 `double` 类型值的数组

```cpp
auto pvalues {std::make_shared<double[]>(10)}; // 创建一个包含 10 个 double 类型值的数组
```

::: tip

在 C++17 标准中，`shared_ptr<>` 已经支持管理动态分配的数组，只是必须使用 `new[]` 运算符分配内存

```cpp
std::shared_ptr<double> pvalues {new double[10]{}};
```

:::

另一种选项是，`shared_ptr<T>` 可以存储在自由存储区中创建的 `array<T>` 或者 `vector<T>` 容器的地址

在下面的这个示例中，将读取任意天数中记录的任意多个温度值。输出每天记录的温度和平均值

```cpp title="tempshared.cpp"
#include <iostream>
#include <format>
#include <memory>  // std::shared_ptr<>
#include <vector>  // std::vector<>
#include <cctype>


int main()
{
    // records 是 vector 对象，存储元素的类型是 shared_ptr<>
    // 每个 shared_ptr<> 对象都指向一个 vector<double> 对象
    std::vector<std::shared_ptr<std::vector<double>>> records;  // [!code highlight]
    // records         record
    //  [ ]  --->  [value1, value2, ...]
    //  [ ]  --->  [value1, value2, ...]
    //  [ ]  --->  [value1, value2, ...]
    size_t day{ 1 }; // 天数

    while (true)
    {
        // 创建一个新的 vector<double> 对象，并用 shared_ptr<> 指向它
        auto record{ std::make_shared<std::vector<double>>() };
        records.push_back(record); // 将 shared_ptr<> 添加到 records 中

        std::cout << "Enter the temperatures for day " << day++ << " separated by spaces. Enter 1000 to end: \n";
        while (true)
        {
            double t{};
            std::cin >> t;
            if (t == 1000.0)
            {
                break;
            }
            record->push_back(t); // 将温度添加到当前 day's vector 中
        }
        std::cout << "Enter another day's temperatures (Y or N)?";
        char answer{};
        std::cin >> answer;
        if (std::tolower(answer) != 'y')
        {
            break;
        }
    }
    day = 1;
    // 遍历 records 中的每一个 shared_ptr<>
    for (auto record : records)
    {
        double total{};
        size_t count{};
        std::cout << std::format("\nTemperature for day {}: \n", day++);
        // record 本质上是一个指向 vector<double> 的指针
        // 想要访问 vector<double> 中的元素，需要解引用指针
        for ( auto temp : *record)
        {
            total += temp;
            std::cout << std::format("{:6.2f}", temp);
            if (++count % 5 == 0)
            {
                std::cout << std::endl;
            }
        }
        std::cout << std::format("\nAverage temperature: {:.2f}", total / count) << std::endl;
    }
}
```

::: tip

这个示例代码中使用 `std::shared_ptr<>` 只是为了提供一个示例。实际上，我们应该使用 `std::vector<std::vector<double>>` 来替换 `std::vector<std::shared_ptr<std::vector<double>>>`

只有当程序的多个部分真正共享相同的对象是，才需要使用 `std::shared_ptr<T>`

:::

## 理解引用

理解引用需要先理解 **左值** 和 **右值** 两个概念。

### 左值和右值

在 C++ 中，对象右两个属性

|属性|描述|
|---|---|
|有身份|该对象有名字; 有该对象的指针; 有该对象的引用|
|可移动|能否把对象的内容移动出来|

上面两个属性共有 $4$ 中组合形式，有 $3$ 中形式在 C++ 语法规则精确描述，其中 **既没有身份又不能移动的对象不重要**，也不需要描述它。下图描述了左值和右值的概念

![1764422095240-698f5202167d5a17b730a159544f40cd.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1764422095240-698f5202167d5a17b730a159544f40cd.png)

一个经典的 **左值是有身份但不能移动**，一个经典的 **右值是允许执行移出操作的对象**

### 定义引用

下面介绍如何定义一个对象的引用。假设我们定义了如下变量

```cpp
double data {3.14}; // 定义一个 double 类型的变量
```

就可以定义一个引用，作为变量 `data` 的别名:

```cpp
double& rdata {data};  // 定义一个引用 rdata，作为 data 的别名
```

**`T&` 符号表示，所定义的变量是对 `T` 类型变量的引用**。在本例中，`rdata` 是对 `double` 类型变量 `data` 的引用。它引用的变量在初始化列表中指定。因此，`rdata` 的类型是 `double&`。**可以把引用作为原始变量名的替代**。例如

```cpp
rdata += 2.5; // 修改 rdata 的值，实际上是修改 data 的值
```

这条语句给 `data` 加上 $2.5$。这里不需要像指针那样解引用，只需要使用引用的名字，就好像它是一个变量一样。引用总是作为真正的别名，除此之外与原始值难以区分。例如，如果取得引用的地址，结果会是指向原始变量的一个指针。

```cpp
double *pdata1 {&rdata};  // 对 rdata 取地址
double *pdata2 {&data};   // 对 data 取地址
```

`pdata1` 和 `pdata2` 都是指向 `data` 变量的指针。**引用没有自己的内存空间**，它只是原始变量的一个别名

::: tip

换句话说，**引用不是对象**（即，没有自己的内存空间），这一点与指针不同。指针是一个对象，存储一个地址，并且有自己的内存空间

:::

下面我们比较指针和引用的不同之处。例如，如下代码定义了一个指针指向 `data` 变量

```cpp
double *pdata {&data}; // 定义一个指针，指向 data 变量
```

之后，就可以使用指针 `pdata` 来修改 `data` 变量的值

```cpp
*pdata += 2.5; // 修改 pdata 指向的值，实际上是修改 data 的值
```

只有解除对指针的引用，才能访问它指向的变量。对于引用，不需要解除引用。引用在某些方面类似于已经解除引用的指针，但不能改变引用的对象。注意：不要形成错误的观念：假设使用之前定义的 `rdata` 引用，下面的代码可以通过编译

```cpp
double other_data = 5.0;
rdata = other_data; // 并没有修改引用的对象 // [!code focus]
```

关键在于，最后这条语句并没有使 `rdata` 引用 `other_data` 变量。`rdata` 引用变量被定义为 `data` 的别名，所以将一直是 `data` 的别名。引用一直与其引用的变量完全对等。换句话说，上面的第二条语句的效果完全相当于

```cpp
data = other_data; // 修改 data 变量的值
```

指针则不同。例如，使用指针 `pdata`，可以编写下面的语句

```cpp
pdata = &other_data; // 将 other_data 的地址赋给 pdata
```

因此，**引用变量非常类似于指针常量（const 指针变量）**

```cpp
double * const pdata {&data}; // 指向 data 变量的指针常量
```

但是要注意，我们说的是 `const` 指针变量，而不是指向 `const` 变量的指针。也就是说，需要在星号后面加上 `const`。使用 `const` 关键字可以定义这样的引用变量

```cpp
const double& const_ref {data}; // 指向 data 变量的 const 引用
```

这样的引用类似于指向 `const` 变量的指针，准确的说，是指向 `const` 变量的 `const` 指针，因为它是一个别名，但是不能通过它来修改原来的变量。例如，下面的语句无法通过编译

```cpp
const_ref *= 2; // error: 不能通过 const 引用修改 data 变量
```

其实，这里我们介绍的是 **左值引用** 和 **const 左值引用**。它们是 C++ 中最常用的引用类型。在后续会介绍 **右值引用**，它们在实现移动语义时非常重要。

::: tip

左值引用：用于引用那些我们希望修改的对象。

const 左值引用：用于引用那些我们不希望修改的对象。这通常用于定义函数接口，防止函数修改传入的参数。

:::

将在 [第八章 定义函数](./008-定义函数.md) 中来操作非基本对象的参数时，对 `const` 变量的引用扮演着特别重要的绝色

### 基于范围的 for 循环中使用引用变量

我们知道，使用基于范围的 `for` 循环可以迭代数组中的所有元素

```cpp
double sum {};
unsigned count {};
double temperatures[] { 72.5, 75.0, 79.8, 83.2, 78.5 };

for (auto t: temperatures)  // 迭代数组中的每一个元素
{
    sum += t;
    ++count;
}
```

在每次迭代时，将变量 `t` 初始化为当前元素的值，从第一个数组元素开始。`t` 不能访问元素本身，而只是一个局部副本，具有与元素相同的值。所以，不能使用 `t` 来修改元素的值。但如果使用引用，就可以修改数组元素

```cpp
const double F2C {5.0 / 9.0};

for (auto &t : temperatures)  // 使用引用迭代数组中的每一个元素
{
    t = (t - 32.0) * F2C;  // 修改数组元素的值
}
```

循环变量 `t` 现在是 `double&` 类型，所以它是每个数组元素的别名。在每次迭代时，循环变量都会重新定义，用当前元素初始化，所以在初始化后引用没有改变。这个循环把 `temperatures` 数组中的值从华氏度修改为摄氏度。在能够使用原始变量或者数组元素的任何地方，都可以使用别名 `t`

在处理对象集合时，基于范围 `for` 循环中使用引用是非常高效的。复制对象的时间成本很高，所以在使用引用类型避免复制可以使代码高效

在基于范围 `for` 循环中，在给变量使用引用类型且不需要修改时，就可以给循环变量使用 `const` 引用类型。例如

```cpp
for (const auto &t : temperatures)  // 使用 const 引用迭代数组中的每一个元素
{
    std::cout << std::format("{:6.2f}", t);  // 访问数组元素的值
}
std::cout << std::endl;
```
