---
title: 基本概念
createTime: 2025/11/13 22:09:25
permalink: /cppstudy/h45ai0rx/
tags:
  - C/C++
---

## C++ 环境环境搭建(**重要**)

下面我们将搭建一个 C++ 环境，从而可以进行代码编写、调试、构建和运行 C++ 程序。根据你使用的不同的操作系统，需要选择不同的 C++ 开发工具

如果你使用的是 Windows，我推荐使用 [Visual Studio IDE](https://visualstudio.microsoft.com/zh-hans/)。当然 [Qt Creator IDE](https://www.qt.io/development/tools/qt-creator-ide) 也可以在 Windows 上工作。我们会介绍这两种 IDE 的安装方式

### Visual Studio IDE

访问 [Visual Studio IDE](https://visualstudio.microsoft.com/zh-hans/) 官网，然后点击免费下载。此时，就会开始下载 Visual Studio IDE 安装程序

![1765719069425-e6b2f9031b1d5847b1315b49dc37d2cf.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1765719069425-e6b2f9031b1d5847b1315b49dc37d2cf.png)

等待下载完成后，双击打开 Visual Studio IDE 安装程序，稍后你将看到如下界面

![1765719193562-6160fe51b69150460698b8f0b2480a12.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1765719193562-6160fe51b69150460698b8f0b2480a12.png)

勾选 `桌面应用和移动应用 => 使用 C++ 的桌面开发` 后点击安装即可。由于我已经安装完成了，并且没有任何修改，所以这里显示的是关闭而不是安装

![1765719571699-5594f5b267e9931da958a811f76ccc16.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1765719571699-5594f5b267e9931da958a811f76ccc16.png)

### Qt Creator IDE(可选的)

Qt Creator IDE 安装就不能像 Visual Studio IDE 那样直接访问官网进行安装。我们需要访问[qtproject USTC](https://mirrors.ustc.edu.cn/help/qtproject.html) 国内镜像下载 Qt 安装程序。根据安装程序的指引完成安装即可

## 第一个 C++ 程序

下面展示第一个完全可以工作的完整 C++ 程序。首先，按照 `打开 Visual Studio IDE => 创建新项目 => 控制台应用 => 下一步` 创建项目，然后回进入一个配置对话框，填写对话框后点击创建

![1765722127284-b9d31fa456842bd33f897daf33af63e3.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1765722127284-b9d31fa456842bd33f897daf33af63e3.png)

这样就完成了 C++ 项目的创建，此时 IDE 给我们生成了一个基础的代码文件

![1765722686736-ff4c00f08c49326e63dbd5fabc4b622e.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1765722686736-ff4c00f08c49326e63dbd5fabc4b622e.png)

我们删除上述所有代码，然后编写如下代码

```cpp title="firstcpp.cpp"
// firstcpp.cpp
// A complete C++ program

import <iostream>;

int main()
{
    int answer {42};

    std::cout << "The answer to life, the universe, and everything is "
            << answer
            << std::endl;

    return 0;
}
```

如何才能运行上述示例程序呢？在 Visual Studio IDE 中，只需要点击工具栏中的绿色三角形即可

![1765722952630-3b35fa5db5083a9ec981581a4a0effb0.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1765722952630-3b35fa5db5083a9ec981581a4a0effb0.png)

点击上面的工具栏上的绿色三角形编译并运行程序。然而，Visual Studio IDE 提示如下错误信息

![1765723132401-62ff2316790e3469e82da8c72534daf8.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1765723132401-62ff2316790e3469e82da8c72534daf8.png)

这是因为 Visual Studio IDE 默认情况下并未开启对 C++ 模块的支持，而是使用旧式的 `#include` 头文件指令。因此，我们需要修改 Visual Studio IDE 的默认配置。

![1765723339520-368754dd460b798e9694bda6658c0adc.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1765723339520-368754dd460b798e9694bda6658c0adc.png)

选择 `菜单栏 => 项目 => firstcpp 和属性` 后，会弹出另一个对话框。在常规属性中，将 C++ 标准设置为 C++20。然后在 `C/C++/常规` 中启用 C++ 模块，如下图所示

![1765723597559-03f2dc017b12c8ae799edf6152a58559.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1765723597559-03f2dc017b12c8ae799edf6152a58559.png)

经过上述配置的修改，此时再次点击运行，应该就能成功编译并执行我们的第一个 C++ 程序了。下图展示了运行结果

![1765723708593-552ac019869053d8061a5902e04e1c5d.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1765723708593-552ac019869053d8061a5902e04e1c5d.png)

### 理解第一个 C++ 程序

第一个 C++ 程序虽然简单，但是五脏俱全。它涉及了 C++ 核心知识点。如下图所示，解释了上述例程的各部分

![1760698880233-d1c183dca2b64702fa726c981fd794af.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1760698880233-d1c183dca2b64702fa726c981fd794af.png)

#### 源文件

我们的示例代码是保存在一个名为 `firstcpp.cpp` 的文件中。文件扩展名 `.cpp` 表示这是一个 **C++ 源文件**。源文件包含函数体和程序中大部分可执行的代码。C++ 的源文件通常带有文件扩展名 `.cpp`。此外，还有其他的扩展名；例如 `.cc` `.cxx` 等

最开始我们学习 C++ 时，程序都会比较小，在一个 C++ 源文件中定义就足够了。但是，实际开发中，程序往往由成千上万个文件组成，这些文件并非都是源文件。在大型程序中，会使用其他类型的文件，目的是将程序各个组成部分的接口（函数原型、类定义、模块接口等）从源文件中的实现中分离出来

::: tip

源文件即是存储 C++ 实现代码的文件，通常以 `.cpp` 和 `.cc` 作为文件扩展名

:::

#### 注释和空白

示例代码的前两行是 **注释**。添加注释用于解释程序代码，可以提高可读性，使他人可以更快的理解程序的工作方式。C++ 中，注释使用 `//` 开头，直到该行结束。编译器会忽略一行代码中 `//` 后面的内容

::: warning

注意：不要在每个文件开头的注释中指出文件名。示例代码只是为了演示

:::

C++ 还支持另外一种形式的注释，它可以让注释跨行存放

```cpp
/* This comment is
over two line
*/
```

编译器会忽略 `/*` 和 `*/` 之间的所有内容。这种注释通常用于文档说明

```cpp
/******************\
* This comment is *
* over two line.  *
\******************/
```

**空白** 是空格、制表符、换行符或者换页符等任意序列。编译器会忽略空白，除非由于语法原因需要使用空白把元素区分开来

#### 标准库模块

示例代码的第四行 `import  <iostream>;` 是一个导入声明，它将 C++ 标准库中的 `<iostream>` 导入到源文件 `firstcpp.cpp` 中。

```cpp{4} title="firstcpp.cpp"
// firstcpp.cpp
// A complete C++ program

#include  <iostream>

int main()
{
    int answer {42};

    std::cout << "The answer to life, the universe, and everything is "
            << answer
            << std::endl;

    return 0;
}
```

这样，由该模块导出的所有类型和函数都可以在该文件中使用了。在编译之前，几乎在每个文件中都要导入一个或多个标准库模块

::: tip

请注意：`<iostream>` 也可以作为头文件，即使用 `#include <iostream>` 预处理指令将头文件包含到当前文件中

实际上，在成为 C++20 的模块之前，它本就是一个头文件。C++20 之前标准库的所有头文件几乎都可以导入 C++20 中，作为模块使用。但是，源于 C 标准库的头文件则不行

:::

#### 函数

每个 C++ 程序都至少包含一个函数，通常会包含多个函数。**函数是一个命名的代码块**，执行定义好的操作，例如，读取输入数据、计算平均值或者输出结果。在程序中，**使用函数的名称来执行或调用函数**，程序中的所有可执行代码都放在函数中

::: warning

C++ 程序中必须有一个名为 `main` 的函数，它是 C++ 程序的执行入口，程序执行总是会从这个函数开始

:::

函数提供了几个重要的特性

+ 程序被分解为不同的函数，更容易开发和测试
+ 一个函数可以在程序的几个不同地方**重用**，从而降低程序的大小
+ 函数还可以在不同的程序中重用，节省开发时间
+ 大程序通常由不同的程序员共同开发。将程序分解为不同的函数可以提高协作效率，每个程序员可以负责不同的函数

我们的示例代码 `firstcpp.cpp` 中只包含 `main()` 函数。如下所示，

```cpp{6-15} title="firstcpp.cpp"
// first.cpp
// A complete C++ program

#include  <iostream>

int main()  // [!code focus]
{
    int answer {42};

    std::cout << "The answer to life, the universe, and everything is "
            << answer
            << std::endl;

    return 0;
}
```

该函数的第一行是 `int main()`，称为 **函数头**，标识了函数。其中 `int` 是一个类型名称，它定义了 `main()` 函数执行完毕时 **返回值的类型** 为整型

::: tip

整型既是存储整数的类型，它是没有小数部分的数字。例如 $23$ 和 $-2048$ 都是整数，但是 $3.1415$ 和 $\frac{1}{4}$ 不是整数

:::

一般情况下，函数定义中名称后面的圆括号，包含了调用函数时需要传递给函数的信息和说明，通常称为函数的 **参数**。函数的可执行代码总是放在花括号（`{}`）中（称为 **函数体**），左花括号跟在函数头的后面

#### 语句

**语句** 是 C++ 程序的基本单元，它总是以分号（`;`）结束。分号表示语句的结束。语句可以定义某个元素，例如计算或者要执行的操作。**程序执行的所有操作都是由语句指定的**。语句按顺序执行，除非某个语句改变了这个执行顺序。例如，`if` 语句。

我们的示例代码中的 `main()` 有 3 个语句。第一条语句定义了一个 **变量**，**变量是一个命名的内存块**，用于存储某种类型的数据。在示例代码中，变量的名称是 `answer`，可以存储整数值

```cpp
int answer {42};  // 定义变量 answer 存储整数 42
```

类型 `int` 放在名称的前面，指定了变量可以存储的数据类型——整数。注意 **`int` 和 `answer` 之间有一个或多个必须得空白字符**，用于分隔类型和变量名。如果 `int` 和 `answer` 之间没有空白字符，编译器会把名字看做 `intanswer`，这是编译器无法理解的。`answer` 的初始值放在变量名后的花括号中，所以它最初存储的值是 $42$。`answer` 和 `{42}` 之间的空格不是必须的。例如，如下几个变量的定义都是有效的

```cpp {1}
int one { 1 };

int two{2};

int three{
    3
};
```

::: tip

虽然编译器会忽略多余的空格，但是在编程时应该以统一的风格使用空白字符，以提高代码可读性

:::

可以将多个语句放在一对花括号（`{}`）中，此时这些语句称为 **语句块**。函数体就是一个语句块。语句块也称为 **复合语句**，因此 **复合语句可以看做是一条语句**。在放置语句的任何地方，都可以放置一个包含在花括号中的语句块。因此，语句块也可以放在其他语句块内部，这个概念称为 **嵌套**。事实上，**语句块可以嵌套任意级别**

#### 数据的输入和输出

在 C++ 中，输入和输出是使用 **流** 来执行的。如果要输出消息，可以把消息写入输出流中；如果要输入数据，则从输入流读取。因此，**流是数据源或数据接收器的一种抽象表示**。在程序执行时，每个流都关联着某台设备，关联着数据流就是输入流，关联着数据目的地的流就是输出流

::: tip

对数据流或者数据接收器使用抽象表示的优点在于，无论流代表什么设备，编程都是相同的。例如，从磁盘文件中读取数据的方式与从键盘上读取是完全相同的

在 C++ 中，标准的输出流和输入流分别称为 `cout` 和 `cin`，默认情况下，它们对应计算机的屏幕和键盘

:::

在我们示例程序中的 `main()` 函数中将文本输出到屏幕的语句

```cpp
std::cout << "The answer to life, the universe, and everything is "
          << answer
          << std::endl;
```

名称 `cout` 和 `endl` 在 `<iostream>` 模块中定义。关于 `std::` 前缀稍后介绍。运算符 `<<` 是插入运算符，用于把数据传递到流中。后续我们还会介绍提取运算符 `>>`，它用于从流中读取数据。每个 `<<` 右边的所有内容都会传递到 `cout` 中。把 `endl` 写入 `std::cout`，会在流中写入一个换行符，并刷新输出缓冲区。刷新输出缓冲区可以确保输出立即显示

可以给每行语句添加注释。例如

```cpp
std::cout << "The answer to life, the universe, and everything is "  // This statement
          << answer                                                  // occupies
          << std::endl;                                              // three lines
```

双斜线不必对齐，但是我们通常对齐双斜线，使之看起来更整齐，代码更容易阅读。当然，不应该只是为了写注释而写注释。注释通常应该包含在代码中无法明显看出来的有用信息

#### return 语句

`main()` 函数中的最后一个语句是 `return`。`return` 语句会结束函数，把控制权返回给调用函数的地方。在之前的示例代码中，它会结束函数，把控制权返回给操作系统。`return` 语句可能返回一个值，也可能不返回值。本例的 `return` 语句向操作系统返回 $0$，表示程序正常结束。程序可以返回非 $0$ 值，表示不同的异常结束条件。在 `main()` 函数中的 `return` 语句是可选的，可以忽略它。程序如果执行超过了 `main()` 函数中的最后一条语句，就等价于执行 `return 0`

::: warning
只有在 `main()` 函数中，忽略 `return` 才相当于返回 $0$。对于其他任何返回类型为 `int` 的函数，最好以一个显式的 `return` 语句结束，否则编译器不知道任意函数在默认情况下应该返回哪个值
:::

#### 名字空间

大项目会同时涉及几个程序员，这样可能会导致名称问题。不同的程序员可能给不同的元素使用相同的名称，这可能会带来混乱，使程序出错。标准库定义了许多名称，很难全部记住。如果不小心使用了标准库名称也会出现问题。名字空间就是用于解决这个问题的

**名字空间类似于姓式**，置于该名字空间中声明的所有名字前面。标准库中的名称都在 `std` 名字空间定义，`cout` 和 `endl` 是标准库中的名称，所以其全名 `std::cout` 和 `std::endl`。其中的两个冒号（`::`）称为 **作用域解析运算符**。这里它用于分隔名字空间中的名字（例如 `cout` 和 `endl`）。名字空间的代码如下所示

```cpp
namespace my_space {
    // All names declared in here need to be prefixed
    // with `my_space` when they are referenced from outside.
    // For example, a `min()` function define in here
    // would be referred to outside this namespace as `my_space::min()`
}
```

花括号对中的所有内容都位于 `my_space` 名称空间中。在 [第 11 章 模块和名字空](./011-模块和名字空.md) 中介绍

### 名字和关键字

在示例代码中包含变量 `answer` 的定义，并使用 `<iostream>` 标准库模块中定义的名字 `cout` 和 `endl`。程序中的许多元素都需要名称，定义名称的准确规则如下

+ 名字可以是包含大小写字母 `A ~ Z` 和 `a ~ z`、数字 `0 ~ 9` 和下划线 `_` 的任意序列
+ 名字必须以字母和下划线开头
+ 名字是区分大小写的

C++ 标准允许名称的任意长度，但有的编译器对此有某种长度限制，这种限制常常比较宽松，并不严格。大多数情况下，不需要使用长度超过 `12 ~ 15` 哥字符的名称

下面是一些有效的 C++ 名称

```cpp
toe_count   shoeSize    Box
doohickey   Doohickey   number1    x1    y2   pValue    out_of_range
```

**大小写字母是由区别的**，所以 `doohickey` 和 `Doohickey` 是不同的名称。编写由两个或多个单词组成的名称时，遵循几个约定

::: tip

+ **小驼峰约定**：把第二个以及之后的各个单词的首字母大写
+ **大驼峰约定**：把第一个以及之后的各个单词的首字母大写
+ **蛇形约定**：把每个单词使用下划线（`_`）分隔

:::

**关键字** 是 C++ 中有特殊含义的保留着，不能把它们用于其他目的。例如，`class`、`int`、`namespace`、`throw` 和 `catch` 都是保留字。此外，避免使用如下名字

+ 连续两个下划线开头的名字。例如，`__add`
+ 以一个下划线后跟一个大写字母开头的名字。例如，`_A`
+ 全局名字空间内所有以下划线开头的名字。例如，`_xxx`

虽然使用上述名字编译器并不会报错。但是，问题在于这些名称可能与编译器生成的名称冲突，或者与标准库实现在内部使用的名称冲突。

::: warning

注意，这些保留名称都具备一个特征：**以下划线开头**。换句话说，在我们的程序中，**应该避免使用以下划线开头的名称**

:::

## 创建可执行程序

从 C++ 源代码中创建可执行的模块通常需要三个步骤。

+ 第一步：预处理器处理所有预处理指令。一般来说，它的关键任务之一就是将所有 `#include` 头文件的完整内容复制到源文件中。但是，由于 C++20 中引入的模块将被淘汰
+ 第二步：编译器把每个源文件转换为对象文件，其他包含了与预处理代码对应的机器码
+ 第三步：链接器把程序的二进制文件合并到包含完整可执行程序的文件中

下图演示了 $3$ 个源文件经过编译后，生成 $3$ 个对应的对象文件。由于标识对象文件的文件扩展名在不同的机器环境中不同，因此没有显示。

![1760698954810-4a24cc47543c5840001f3dec666c3ce1.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1760698954810-4a24cc47543c5840001f3dec666c3ce1.png)

组成程序的源文件可以在不同的编译器运行期间单独编译，但大多数编译器都允许在一次运行期间编译它们。无论采用哪种方式，编译器都把每个源文件看做一个独立的实体，为每个 `.cpp` 文件生成一个对象文件。然后在链接步骤中，把程序的对象文件和必要的库函数组合到一个可执行文件中


![1760699007338-5a9065b0df4b70a28dbaf0361a107f51.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1760699007338-5a9065b0df4b70a28dbaf0361a107f51.png)


![1759497113227-1f1cd432d9b2e601afe893317b53c446.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1760869654967-1f1cd432d9b2e601afe893317b53c446.png)


+ IEEE 754 binary 格式的 $\pm 0$: 指数位全为 0，尾数为全为 0

    ![1760870896639-c070b008836cf807f10d62741b2983db.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1760870896639-c070b008836cf807f10d62741b2983db.png)

+ IEEE 754 binary 格式表示的 $\pm \infty$: 指数为全为 1，尾数位全为 0

    ![1760870961002-f9f87c7e3f73ec3c996f7ed9bbc91591.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1760870961002-f9f87c7e3f73ec3c996f7ed9bbc91591.png)

+ IEEE 754 binary 格式的 NaN：指数全为 1，尾数不全为 0

    ![1760870996864-db6a9793663f817ccbc03b0ef4f0d7d4.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1760870996864-db6a9793663f817ccbc03b0ef4f0d7d4.png)


![1760871305077-afda2594290d6f5b0215d96d8a3a3cb0.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1760871305077-afda2594290d6f5b0215d96d8a3a3cb0.png)


![1760886165334-3715b12195f349bfad34f35bcea652c0.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1760886165334-3715b12195f349bfad34f35bcea652c0.png)

