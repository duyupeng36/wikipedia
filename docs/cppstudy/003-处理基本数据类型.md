---
title: 处理基本数据类型
createTime: 2025/11/13 22:09:25
permalink: /cppstudy/culxxi2t/
tags:
  - C/C++
---

本节解释基本类型的变量如何在复杂环境下交互。此外，还要讨论 C++ 的一些新功能，并讨论使用这些功能的一些方式

+ 如何确定表达式的执行顺序
+ 位运算符的概念及其用法
+ 变量的作用域的概念及作用
+ 变量的存储期限及其决定因数
+ 如何定义新类型，并把其变量的值限定为一组固定数量的可能值
+ 如何为自己的数据类型定义替代名称

## 运算符的优先级和相关性

如前所述，表达式中的算术运算符有特定的执行顺序。我们马上会介绍其他运算符。一般而言，**表达式中运算符的执行顺序由运算符的优先级决定**

然而，运算符 `+`(加法) 和 `-`(减法) 的优先级相同，表达式 `a + b - c + d` 如何计算呢？当表达式中包含相同优先级的几个运算符时，执行顺序由运算符的相关性决定。相关性，在某些教科书中也称为 **结合性**。运算符可以具有 **左相关性**：即，从左到右进行计算；也可以具有 **右相关性**：即，从右到左进行计算

::: tip
大部分运算符都具有左相关性。具有右相关性的运算符包括一元运算符、赋值运算符和条件运算符
:::

下表列出了 C++ 中所有的运算符的优先级及其相关性，或者参考 [C++运算的优先级](https://en.cppreference.com/w/cpp/language/operator_precedence.html)

![1762355922032-adaba286907d4c61b33caa118a554c68.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1762355922032-adaba286907d4c61b33caa118a554c68.png)

每一行都是一个优先级相同的运算符组。运算符组的排列也是按从高到低的顺序。通常，我们不用记忆这些运算符的优先级，在不确定计算顺序时，我们可以通过添加圆括号的方式强制让括号内的运算符先执行

## 位运算符

**位运算符允许按照位来操作整型变量**。无论是有符号整型还是无符号整型，位运算符都支持，包括 `char` 类型。这些运算符的一个常见应用就是设置整型变量中的单个位。单个位常常用作标记，用于描述二进制状态指示符。可以使用一个位来存储两种状态的值

也可以用于位运算符来处理存储在单个变量中的几个信息项。例如，颜色值常常记录为 $3$ 个八位的值，分别存储颜色中的红、绿和蓝成分。这些常常保存到四字节变量的 $3$ 个字节中。第四个字节也不会浪费，包含表示颜色的透明度值（称为颜色的 `alpha` 值）。这种颜色编码称为 RGBA 或者 ARGB，其他字母的顺序对应着红(R)、绿(G)、蓝(B) 和 透明度(A) 成分在 $32$ 位整数中出现的顺序，每个称为存储为 $1$ 字节。显然，要处理各个颜色成分，就需要从变量中分离出各个字节

再看一个例子，假定需要记录字体信息，存储每种字体的样式和字号，以及字体是粗体还是斜体，就可以把这些信息存储在一个两字节的整型变量中。如下图所示

![1762357180443-ec5c094ee83238e0db2a331d53a70991.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1762357180443-ec5c094ee83238e0db2a331d53a70991.png)

上图所示中，使用 $16$ 位存储字体信息。使用一位记录字体是否为斜体($1$表示斜体，$0$表示正体)。另外使用一位记录字体是否为粗体($1$ 表示粗体，$0$ 表示斜体)。使用 $8$ 存储 $256$ 种字体样式中的一种；再用另外 $5$ 位记录最多 $31$ 磅的字号。因此，在 $16$ 位的位模式中，可以记录 $4$ 种不同的信息。位运算符提供了访问和修改整数中单个位和一组位的方式，能方便的组合和分解一个 $16$ 位位模式

### 移位运算符

移位运算符可以把整型变量中的内容向左或向右移动指定位数。运算符 `>>` 把位向右移动，运算符 `<<` 把位向左移动，移出两端的位被舍弃。所有的位运算符都可以处理任何类型的整数，但是我们采用 `short` 类型，通常包含两字节。

用下面的语句声明并初始化一个变量 `number`

```cpp
unsigned short number {16387};
```

使用下面的语句，可以对这个变量的内容进行移位

```cpp
auto result {static_cast<unsigned short>(number << 2)};  // 左移 2 位
```

::: warning 警告
表达式 `number << 2` 结果的类型是 `int`，因为编译器会将 `unsigned short` 类型转换为 `int` 类型
:::

左移运算符 `<<` 的左操作数是要移位的值，右操作数指定要移动的位数。右移运算符 `>>` 的操作数是要移位的值，右操作数指定要移动的位数。如下图所示，演示了这两个运算符操作的结果

![1762440617085-238c65ef4a8d8dad79a30281a0cc31a1.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1762440617085-238c65ef4a8d8dad79a30281a0cc31a1.png)

从上图中可以看出，把数值 $16387$ 向左移动 $2$ 位，得到数值 $12$。数值这种剧烈变化是舍弃高位数字的结果。下面的语句把数值向右移动两位

```cpp
result = static_cast<unsigned short>(number >> 2);  // 向右移动两位
```

把数值 $16387$ 向右移动 $2$ 位，得到数值 $4096$。向右移动两位相当于使数值除以 $4$。只要没有舍弃位，向左移动 $n$ 位相当于把数值乘以 $2^n$。同样，向右移动 $n$ 位就相当于把数值乘以 $2^n$。

::: warning 注意
变量 `number` 向左移动时，如果舍弃了有效位，结果就不是我们希望的那样了。这与乘法没有什么不同。如果把 $2$ 字节的数值乘以 $4$，就会得到相同的结果，所以向左移位和相乘仍是等价的
:::

使用移位运算符修改变量原来的值时，可以使用 `>>=` 或者 `<<=` 运算符。例如

```cpp
number >>= 2;  // 向右移动 2 位
```

等价于

```cpp
number = static_cast<unsigned short>(number >> 2);
```

移位运算符与输入和输出的插入和提取运算符不可能发生混淆。编译器可以从上下文中推断出来。当需要直接输出表达式 `number << 2` 的结果时，需要使用圆括号将该表达式包围起来，否则编译器会将 `<<` 识别为插入运算符

```cpp
std::cout << number << 2 << std:endl;  // 163872("1637" "2")
```

必须通过添加圆括号来解决这个问题

```cpp
std::cout << (number << 2) << std:endl;
```

然而，上述表达式输出的结果也不会是 $12$，而是输出 $65548$，即 $16387 \times 4$ 的结果。这是因为编译器的隐式类型转换，表达式 `number << 2` 的结果的类型是 `int`。想要得到正确的结果，必须使用 `static_cast<>` 进行强制类型转换

```cpp
std::cout << static_cast<unsigned short>(number << 2) << std:endl;
```

#### 有符号整数的移位

C++ 标准要求使用 $2$ 的补码表示有符号整数进行编码。移位运算符对有符号整数的移位处理与无符号整数存在差异

对于负数，**右移运算符** 会在左边空出的位上填充 $1$；对于正数，则填充 $0$，这种操作称为 **符号扩充**。**扩充符号位的原因是为了保持向右移位和除法运算保持一致**。例如

```cpp
signed char negative {-104}; // 10011000
negative >>= 2; // 10011000  >> 2 => [11100110]'00 = -104 / 4 = -26
```

对于 **左移运算符** 无论是正数还是负数，都会在右边空出的位上填充 $0$。这与无符号整数的左移运算是相同的。例如

```cpp
signed char negative {-104}; // 10011000
negative <<= 2; // 10011000 << 2 => 10'[01100000] = 2^6 + 2 ^ 5 = 96
```

### 位模式下的逻辑运算

修改整数中的位时，可以使用下表列出的 $4$ 个按位运算符。该表中的运算符按照优先级进行降序排序。所以，运算符 `~` 的优先级最高，运算符 `|` 的优先级最低。

| 运算符  | 描述                                                      |
|:---- |:------------------------------------------------------- |
| `~`  | 按位求反。它是一元运算符，可以反转操作数中的位，即 $1$ 变成 $0$，$0$ 变成 $1$         |
| `&`  | 按位与运算符。对操作数中相应的位进行与运算。相应位都是 $1$，结果位就是 $1$；否则，结果位就是 $0$  |
| `^`  | 按位异或。对操作数中相应位进行异或运算。相应位不同，结果位就是 $1$；否则，结果位就是 $0$        |
| `\|` | 按位或。对操作数中相应位进行或运算。相位中只要有一个位是 $1$，结果位就是 $1$；否则，结果位就是 $0$ |

移位运算符 `>>` 和 `<<` 具有相同的优先级，优先级低于运算符 `~`，高于运算符 `&`

#### 使用按位与运算符

按位与运算符一般用于选择整数值中特定的位或者位域。下面我们假定在 $16$ 位整数中的存储字体的字号、字形、是否位粗体、是否位斜体。如下图所示，

![1762529658037-f47f23f1ea41c6bb41402918a93640b0.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1762529658037-f47f23f1ea41c6bb41402918a93640b0.png)

由于 $4$ 个二进制数等于 $1$ 十六进制数，因此最简洁的方法是使用十六进制形式指定初始值

```cpp
unsigned short font {0x064c};
```

当然，从 C++14 开始，可以直接使用二进制字面值初始化

```cpp
unsigned short font {0b00000110'0'10'001100};
```

要使用字号，就需要从 `font` 变量中提取它。按位与运算符就可以达到这个目的。只有当两个位都是 $1$ 时，按位与运算符才会生成 $1$，所以可以定义一个值，将定义字号的位和 `font` 执行按位与操作时选择该为。该值在我们感兴趣的位上包含 $1$，在其他位上包含 $0$。这种值称为 **掩码(mask)**

::: tip
代表字号的位域在 `font` 变量的最后 $5$，我们需要将掩码的最后 $5$ 位设置为 $1$，其他位设置为 $0$ 即可

```cpp
unsigned short size_mask {0x1FF};  // 字号掩码
```

:::

有了掩码之后，就可以通过按位与运算符将字号从 `font` 变量中分离出来

```cpp
unsigned short font_size {static_cast<unsigned short>(font & size_mask)};
```

下图演示了上述表达式的计算原理

![1762586997396-95b3872407f79e00afb127a5ef1e0d1a.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1762586997396-95b3872407f79e00afb127a5ef1e0d1a.png)

同理，从 `font` 中获取字体样式，就需要定义一个字体样式掩码，然后与 `font` 进行按位与运算。由于字体样式在最左边，还需要将结果向右移动

```cpp
unsigned short style_mask {0xFF00};
unsigned short style {static_cast<unsigned short>((font & style_mask) >> 8)};
```

::: tip
位运算的另一个用途就是清空位域。只需要将带清空位域范围内的掩码设置为 $0$ 其他位设置为 $1$，然后在进行按位与运算，就能将掩码为 $0$ 的位域清空
:::

#### 使用按位或运算符

按位与运算符的作用是用于 **获取** 整数变量指定为位或位域。如果想要 **设置** 整数变量的指定位或位域，那么可以使用 **按位或运算符**。继续操作前面的 `font` 变量，现在需要设置斜体和粗体位。用下面的语句定义掩码，选择这些位

```cpp
// 斜体掩码
unsigned short italic_mask {0x40};  // 0000 0000 0100 0000
// 粗体掩码
unsigned short bold_mask {0x20};    // 0000 0000 0010 0000
```

除了直接使用字面值初始化掩码之外，还可以通过移位的方式。回顾之前关于字体的整数变量

![1762529658037-f47f23f1ea41c6bb41402918a93640b0.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1762529658037-f47f23f1ea41c6bb41402918a93640b0.png)

代表斜体的位在右边第 $7$ 位；代表粗体的位在右边第 $6$ 位。因此，我们只需要将 $1$ 向左移动 $6$ 位或者 $5$ 位就能得到斜体和粗体位域的掩码

```cpp
// 斜体掩码
unsigned short italic_mask {1u << 6};  // 0000 0000 0100 0000
// 粗体掩码
unsigned short bold_mask {1u << 5};    // 0000 0000 0010 0000
```

::: warning 警告
请记住，要打卡第 $n$ 位，只需要将 $1$ 向左移动 $n-1$ 位。注意，这里是以 $1$ 为起始值从右开始计数。简单来说，移动 $0$ 位得到第 $1$ 个位，移动 $1$ 位得到第 $2$ 个位
:::

如果想要将字体修改为粗体，只需要将 `font` 变量与 `bold_mask` 进行按位或运算即可

```cpp
font |= bold_mask;
```

位的组合如下图：掩码中的 $1$ 被合并到了整数变量中

![1762622692505-1b0814d210c1b961e75fee97fc8f621e.png](https://cdn.jsdelivr.net/gh/duyupeng36/images@master/wiki/1762622692505-1b0814d210c1b961e75fee97fc8f621e.png)

#### 使用按位取反运算符

现在，我们需要将字体设置为正体，即需要关闭字体中表示斜体的位。正如之前所言，可以使用按位与运算符关闭位，只要定义一个掩码，将需要关闭的位设置为 $0$，其他位设置为 $1$，然后在进行按位与运算即可

如果要显式指定它，就需要知道变量中有多少个字节要修改，如果希望程序可以用任何方式移植，这就很不方便。不过，在用于打开位的掩码上使用按位求反运算符，就可以得到这样的掩码。对于打开粗体的 `bold_mask` 进行求反，就可以得到关闭粗体的掩码

```shell
 bold: 0000 0000 0010 0000  # 打开粗体掩码
~bold: 1111 1111 1101 1111  # 关闭粗体掩码
```

按位求反运算符的作用是反转原有数值中的每一位，使 $0$ 变 $1$，$1$ 变 $0$。无论 `bold_mask` 变量占几个字节，都会生成我们期望的结果。因此，关闭粗体位时，只需要对 `bold_mask` 按位求反和 `font` 执行按位与操作

```cpp
font &= ~bold_mask
```

还可以使用 `&` 运算符把几个掩码组合起来，再对结果与要修改的变量执行按位与操作，将多个位设置为 $0$

```cpp
font &= ~bold_mask & ~italic_mask;
```

这条语句把 `font` 变量中的斜体和粗体位设置为 $0$。这里不需要圆括号，因为 `~` 运算符的优先级高于 `&` 运算符。如果不确定运算符的优先级，就应该使用圆括号，表示希望执行的操作。注意，使用下面的语句可以得到相同的效果

```cpp
font &= ~(bold_mask | italic_mask); // 这里必须使用圆括号
```

#### 使用按位异或运算符

只有当对应的输入位只有一个位等于 $1$、另一个位等于 $0$ 的时候，按位异或运算符的结果才是 $1$。当两个输入位相等时，即使它们都是 $1$，结果位也是 $0$。下表展示了三种位运算符的真值表

| `x` | `y` | `x AND y` | `x OR y` | `x XOR y` |
|:--- |:--- |:--------- |:-------- |:--------- |
| 0   | 0   | 0         | 0        | 0         |
| 1   | 0   | 0         | 1        | 1         |
| 0   | 1   | 0         | 1        | 1         |
| 1   | 1   | 1         | 1        | 0         |

XOR 运算符有一个有趣的属性：它可以用来切换或反转单个位的状态。仍然使用前面定义的 `font` 变量和 `bold_mask`，下面的语句切换了粗体位的状态。即，如果该为原来是 $0$，现在将成为 $1$；如果原来是 $1$，现在将成为 $0$

```cpp
font ^= bold_mask;
```

这就实现了典型的字处理程序中单击加粗按钮的效果。如果选定文本还不是粗体，就会变为粗体；如果选定文本已经是粗体，就会变为常规的未加粗状态

```shell
font:                           0000 0110 0100 1100   // 非粗体
bold_mask:                      0000 0000 0010 0000
font ^ bold_mask:               0000 0110 0110 1100   // 粗体
font ^ bold_mask ^  bold_mask : 0000 0110 0100 1100   // 非粗体
```

## 变量的生存期和作用域

所有的变量都有有限的生存期。它们从被声明的那一刻起存在，并在某一刻消失，最迟在程序终止时消失。变量生存多长时间取决于存储持续时间。变量拥有的存储持续时间有如下 $4$ 种

+ **自动存储持续时间**：从声明它那一刻起存在，到包含其声明的代码块的结尾处消失。它们被称为 **自动变量** 或者 **局部变量**
+ **静态存储持续时间**：使用关键字 `static` 定义的变量。它从定义的那一刻起存在，直到程序结束时消失
+ **动态存储持续时间**：运行期分配内存的变量。它们从创建的那一刻起存在，直到显式销毁内存。如果不显式销毁内存，那么它将一直存在
+ **线程存储持续时间**：使用关键字 `thread_local` 声明的变量

变量的另一个属性就是 **作用域**。变量的作用域是变量名有效的那部分程序。在变量的作用域内，可以合法地引用它，设置它的值，或者在表达式中使用它。在变量的作用域之外，就不能引用它的名称，如果这样做，会导致编译器提示错误。在变量的作用域之外，变量仍然可能存在，只是不能通过变量名引用它而已。

::: tip
变量的生存期和作用域是两个完全不同的概念。生存期是变量存在的执行时间段，作用域是可以使用变量名的程序代码区域。不要把它们混淆了
:::

下面的代码演示了变量的作用域

```cpp
long value1;  // 全局变量：作用域直到文件末尾结束

int main()
{
    int value2{};  // 局部变量：作用域直到 main 函数结束
    ...
    {
        int value3{}; // 局部变量：作用域直到代码块结束
        ...
    }
}

int function(int)
{
    long value5{}; // 局部变量：作用域直到 function 结束
    int value1{};
    ....
}
```

::: tip
常见的编码和设计规范要求尽量避免使用全局变量。但是，全局常量，也就是使用 `const` 声明的全局变量。建议所有的常量只定义一次，全局变量非常适合这种用途
:::

## 枚举类型

有时候需要使变量具有限定的一组值，并可以通过名称来引用这些值。例如，一星期的每一天或者一年的各个月。枚举类型提供了这个功能。在定义枚举时，实际上是在创建一个新的类型，所以它也称为枚举数据类型。例如，下面的语句定义了一个星期的每一天

```cpp
// 定义枚举类型
enum class Day {
    Monday,    // 枚举成员。默认值为 0
    Tuesday,   // 值为 1
    Wednesday, // 值为 2
    Thursday,
    Friday,
    Saturday,
    Sunday
};
```

这条语句定义了枚举类型 `Day`，这个类型的变量值只能是花括号中的值。如果把 `Day` 类型的变量值设置为不在花括号中的值，代码就不能编译。列在花括号中的符号名称称为枚举成员

默认情况下，每个枚举成员都自动定义为一个 `int` 类型的固定整数值。列表中的第一个名称是 `Monday`，值为 $0$，`Tuesday` 的值为 $1$，...，`Sunday` 的值为 $6$。可以用下面的语句把 `today` 定义为枚举类型 `Day` 的一个变量

```cpp
Day today {Day::Tuesday};
```

类型 `Day` 的用法和基本类型相似。`today` 的定义还把该变量的值初始化为 `Day::Tuesday`

::: warning
请注意：引用枚举时，必须用类型名限定它
:::

如果输出 `today` 的值，就必须把它转换为数值类型，因为标准输出流不能识别 `Day` 类型

```cpp
std::cout << "Today is " << static_cast<int>(today) << std::endl;
// Today is 1
```

默认情况下，每个枚举成员的值都比前面一个枚举成员的值大 $1$，第一个枚举成员的值默认是 $0$。赋予枚举成员的隐式值也可以从另一个整数开始。例如，下面的语句使 `Day` 枚举成员的值为 $1 \sim 7$

```cpp
// 定义枚举类型
enum class Day {
    Monday = 1,  // 枚举成员。默认值为 1
    Tuesday,     // 值为 2
    Wednesday,
    Thursday,
    Friday,
    Saturday,
    Sunday
};
```

枚举成员 `Monday` 被显式指定为 $1$，后续枚举成员都比前一个枚举成员大 $1$。请注意：**可以为枚举成员赋予任何整数值**，并且并不是只能对前几个枚举成员赋值

```cpp
// 定义枚举类型
enum class Day {
    Monday = 3,  // 枚举成员。默认值为 3
    Tuesday,     // 值为 4
    Wednesday,
    Thursday,
    Friday,
    Saturday = 1,  // 值为 1
    Sunday         // 值为 2
};
```

**枚举成员不一定有唯一值**。可以把 `Monday` 和 `Mon` 都定义为 $1$。例如

```cpp
// 定义枚举类型
enum class Day {
    Monday = 1,  // 枚举成员。默认值为 1
    Mon = 1,     // 值为 1
    Tuesday,     // 值为 2
    Wednesday,
    Thursday,
    Friday,
    Saturday,
    Sunday
};
```

还可以根据前面的枚举成员定义新的枚举成员值。例如

```cpp
// 定义枚举类型
enum class Day {
    Monday = 1,  // 枚举成员。默认值为 1
    Mon = Monday,
    Tuesday = Monday + 2,     // 值为 3
    Wednesday = Tuesday + 2,  // 值为 5
    Thursday = Wednesday + 2, // 值为 7
    Friday = Thursday + 2,    // 值为 9
    Saturday = Friday + 2,    // 值为 11
    Sunday = Saturday + 2     // 值为 13
};
```

**枚举成员可以是任何整数类型**。也可以给所有的枚举成员显式赋值

```cpp
// 定义标点符号枚举
enum class Punctuation: char {
    Comma = ',',
    Exclamation = '!',
    Question = '?'
};
```

如下演示了枚举类型的用法

```cpp
// 操作枚举
#include <iostream>
#include <format>

int main()
{
    enum class Day {
        Monday,    // 枚举成员。默认值为 0
        Tuesday,   // 值为 1
        Wednesday, // 值为 2
        Thursday,
        Friday,
        Saturday,
        Sunday
    };

    Dat yesterday {Day::Monday}, today {Day::Tuesday}, tomorrow{Day::Wednesday};
    const Day poets_day {Day::Friday};

    // 定义标点符号枚举
    enum class Punctuation: char {
        Comma = ',',
        Exclamation = '!',
        Question = '?'
    };

    Punctuation ch{Punctuation::Comma};

    std::cout << std::format("yesterday's value is {}{} but poets_day's is {}{}\n", static_cast<int>(yesterday), static_cast<char>(ch), static_cast<int>(poets_day), static_cast<char>(Punctuation::Exclamation));

    today = Day::Tursday;
    ch = Punctuation::Question;
    tomorrow = poets_day;

    std::cout << std::format("Is today's value({}) the same as poets_day({}){}\n", static_cast<int>(today), static_cast<int>(poets_day), static_cast<char>(ch));
}
```

使用 `enum class` 定义的枚举类型成为 **限定作用域的枚举**。默认情况下，如果不将类型的名称指定为作用域，就不能使用它们的枚举成员。必须添加 `Day::` 作为其作用域。在 C++20 中，可以通过 `using enum` 或者 `using` 声明绕过这个限制

```cpp
using enum Day;
today = Friday;

using Punctuation:Comma;
ch = Comma;
```

::: warning
作用域的枚举废弃了旧枚举语法。旧式枚举现在没称为无作用域枚举。在定义枚举类型时，不添加额外的 `class` 关键字

```cpp
enum Day {Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday};
```

旧式枚举成员在转换为整数类型甚至浮点类型时，不必进行显式类型转换，这很容易导致出错
:::

## 名字空间的 using 指令

重复指定名字空间的名称往往是非常麻烦的，甚至损害了代码的可读性。在 C++ 源文件中，可以使用 **`using` 声明**，从而避免使用名字空间限定特定的名字

```cpp
using std::cout;  // using 声明：相当于在当前作用域声明了一个变量 cout
```

这告诉编译器，在遇见 `cout` 时，将其解释为 `std::cout`。这样可以使得代码看起来跟整洁

```cpp
using std::cin;
using std::cout;
using std::format;
```

`using` 指令导入指定名称空间中的全部名称。例如

```cpp
using namespace std; // using 指令：指示编译器在 std 名字空间中搜索名字
```

## 数据类型的别名

`using` 关键字允许指定数据类型别名，即把指定另一个类型名称代表原来的数据类型。例如

```cpp
using BigOnes = unsigned long long;
```

注意：**这里并没有定义新类型**，只是把 `BigOnes` 定义为类型 `unsigned long long` 的替代名字。这样就可以使用 `BigOnes` 定义变量了

```cpp
BigOnes num {};
```

类型别名的旧式语法是使用关键字  `typedef`。例如，可以采用如下方式定义类型别名 `BigOnes`

```cpp
typedef unsigned long long BigOnes;
```

::: tip
新语法的优势在与非常直观，看起来像是赋值语句。别名位于 `=` 的左侧，源类型位于右侧。但是，`typedef` 却是源类型在前，别名在后。
:::
